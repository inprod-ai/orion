# Orion Cursor Rules

## Project Overview
Production readiness analysis platform built with Next.js 16, TypeScript, Prisma, and custom GitHub OAuth.

## TypeScript Conventions

### Strict Mode
- TypeScript strict mode is enabled in tsconfig.json.
- Never use `// @ts-ignore` or `// @ts-expect-error` without explanation.
- Never use `any` without explicit comment justifying it; prefer `unknown` with type guards.
- Prefer explicit return types on exported functions.

### Type Definitions
- Define interfaces for all API request/response shapes.
- Colocate types with their usage when specific to one file.
- Share common types in `types/` or `lib/orion/types.ts`.
- Use `type` for unions/intersections, `interface` for object shapes.

## File Naming Conventions

### General Rules
- Utilities/lib files: `kebab-case.ts` (github-auth.ts, stack-detector.ts)
- React components: `PascalCase.tsx` (UserMenu.tsx, RepoSelector.tsx)
- API routes: `route.ts` in kebab-case directories (api/auth/login/route.ts)
- Type files: `types.ts` or domain-specific like `analysis.ts`
- Test files: `name.test.ts` mirroring source structure in tests/

### Directory Structure
```
app/
  api/
    auth/
      login/route.ts
      callback/route.ts
  page.tsx
components/
  UserMenu.tsx
  RepoSelector.tsx
lib/
  github-auth.ts
  prisma.ts
types/
  analysis.ts
tests/
  orion/
    analyzer.test.ts
```

## Import Order

Organize imports in this exact order with blank lines between groups:

```typescript
// 1. React
import { useState, useEffect } from 'react'

// 2. Next.js
import { NextRequest, NextResponse } from 'next/server'
import { useRouter } from 'next/navigation'
import Link from 'next/link'

// 3. External packages (alphabetical)
import Anthropic from '@anthropic-ai/sdk'
import { motion } from 'framer-motion'
import { z } from 'zod'

// 4. Internal absolute imports (@/ aliases)
import { prisma } from '@/lib/prisma'
import { getSession } from '@/lib/github-auth'
import type { AnalysisResult } from '@/types/analysis'

// 5. Relative imports
import { helperFunction } from './utils'
```

## React Patterns

### Components
- Use function components with TypeScript, never class components.
- Props interface named ComponentNameProps or inline for simple cases.
- Destructure props in function signature.
- Use 'use client' directive only when needed (useState, useEffect, event handlers).

### Hooks
- Custom hooks in hooks/ directory, named useName.
- Prefer useCallback for functions passed as props.
- Avoid useEffect for derived state; compute inline or use useMemo.

## API Route Patterns

### Structure with Zod Validation
```typescript
// =============================================================================
// API: /api/example - Brief description
// =============================================================================

import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'
import { getSession } from '@/lib/github-auth'
import { prisma } from '@/lib/prisma'

const RequestSchema = z.object({
  repoUrl: z.string().url(),
  options: z.object({
    deep: z.boolean().optional(),
  }).optional(),
})

export async function POST(request: NextRequest) {
  try {
    // 1. Validate request size
    const contentLength = request.headers.get('content-length')
    if (contentLength && parseInt(contentLength) > 10240) {
      return NextResponse.json({ error: 'Request too large' }, { status: 413 })
    }

    // 2. Auth check (if needed)
    const session = await getSession()
    if (!session?.userId) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 })
    }

    // 3. Parse and validate input with Zod
    const body = await request.json()
    const parsed = RequestSchema.safeParse(body)
    
    if (!parsed.success) {
      return NextResponse.json(
        { error: 'Invalid request', details: parsed.error.flatten() },
        { status: 400 }
      )
    }

    const { repoUrl, options } = parsed.data

    // 4. Business logic
    const result = await doSomething(repoUrl, options)

    // 5. Return response
    return NextResponse.json({ data: result })
  } catch (error) {
    // Sanitize error for production - never expose internals
    console.error('POST /api/example error:', error)
    return NextResponse.json(
      { error: 'Something went wrong. Please try again.' },
      { status: 500 }
    )
  }
}
```

### Error Handling
- Wrap entire handler in try/catch.
- Return JSON errors with appropriate status codes:
  - 400: Bad input (validation failed)
  - 401: Not authenticated
  - 403: Forbidden (authenticated but not authorized)
  - 404: Not found
  - 413: Request too large
  - 429: Rate limit exceeded
  - 500: Internal server error
- Log errors with console.error including route context.
- Never expose stack traces, internal paths, or error details to client.

### Security
- Always validate input with Zod schemas.
- Use parseGitHubUrl() for URL inputs (SSRF protection).
- Check session ownership before returning user-specific data.
- Set request size limits with content-length header checks.

## Tailwind CSS Organization

### Class Order
Organize Tailwind classes in this order:

1. Layout: flex, grid, block, hidden
2. Positioning: relative, absolute, fixed, inset-0, z-10
3. Box Model: w-, h-, p-, m-, gap-
4. Typography: text-, font-, leading-, tracking-
5. Visual: bg-, border-, rounded-, shadow-
6. Effects: opacity-, blur-, backdrop-
7. Transitions: transition-, duration-, ease-
8. States: hover:, focus:, active:, disabled:
9. Responsive: sm:, md:, lg:, xl:

### Component Classes
- Use cn() utility from lib/utils.ts for conditional classes.
- Extract repeated class patterns into component props.

```tsx
import { cn } from '@/lib/utils'

<button className={cn(
  'px-4 py-2 rounded-lg font-semibold transition-colors',
  variant === 'primary' && 'bg-purple-500 text-white hover:bg-purple-600',
  disabled && 'opacity-50 cursor-not-allowed'
)}>
```

## Prisma Best Practices

### Queries
- Use select to fetch only needed fields.
- Use findUnique for single record by unique field, findFirst for other single records.
- Always handle null results.

### Mutations
- Use upsert for create-or-update patterns.
- Use transactions for multi-table operations.
- Validate data before database operations.

### Performance
- Avoid N+1 queries; use include or batch operations.
- Use pagination for list endpoints.

## Naming Conventions

### Variables and Functions
- camelCase for functions, variables, object properties.
- Verb prefixes: get, fetch, create, update, delete, handle, on.

### Components and Types
- PascalCase for React components, interfaces, types, enums.

### Constants
- SCREAMING_SNAKE_CASE for true constants.

## Testing with Vitest

### File Naming
- Test files: name.test.ts or name.test.tsx
- Located in tests/ directory mirroring source structure.

### Test Structure
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest'

describe('functionName', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('should do expected behavior', () => {
    const result = functionName(input)
    expect(result).toBe(expected)
  })

  it('should handle edge case', () => {
    expect(() => functionName(badInput)).toThrow()
  })
})
```

### Testing Philosophy
- Write tests that challenge code, find edge cases, and reveal vulnerabilities.
- Dont write tests just to pass; write tests to break code.
- Test error paths as thoroughly as happy paths.
- Mock external dependencies (Prisma, fetch, APIs).

## Code Style

### File Headers
For significant files:
```typescript
// =============================================================================
// MODULE NAME - Brief description
// =============================================================================
```

### Comments
- Explain why, not what (code should be self-documenting).
- No commented-out code; delete it.

### Error Messages
- User-facing: friendly, actionable (Please sign in again)
- Logs: technical, contextual (GitHub API error: 401 - token expired)

## Forbidden Patterns

- No any without explicit comment justifying it.
- No ts-ignore or ts-expect-error without explanation.
- No console.log in production code (use console.error for errors only).
- No synchronous file I/O.
- No secrets in code (use env vars).
- No .env files committed to git.
- No exposing internal error details to clients.
- No raw SQL without parameterized queries.
