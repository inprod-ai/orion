// =============================================================================
// ERROR HANDLING GENERATION
// =============================================================================

import { GeneratedFile, Gap, RepoContext } from '../types'

/**
 * Generate error handling fixes for identified gaps
 */
export async function generateErrorHandling(
  ctx: RepoContext,
  gaps: Gap[]
): Promise<GeneratedFile[]> {
  const files: GeneratedFile[] = []
  
  // Generate Sentry setup if no monitoring
  const noMonitoring = gaps.find(g => g.id === 'error-no-monitoring')
  if (noMonitoring) {
    files.push(...generateSentrySetup(ctx))
  }
  
  // Generate error boundaries for React
  const noBoundaries = gaps.find(g => g.id === 'error-no-boundaries')
  if (noBoundaries && ctx.techStack.frameworks.includes('react')) {
    files.push(generateErrorBoundary())
  }
  
  // Generate structured logging
  const noLogging = gaps.find(g => g.id === 'error-no-logging')
  if (noLogging) {
    files.push(generateLogger())
  }
  
  // Generate global error handler
  const noGlobalHandler = gaps.find(g => g.id === 'error-no-global-handler')
  if (noGlobalHandler) {
    files.push(generateGlobalErrorHandler())
  }
  
  return files
}

/**
 * Generate Sentry setup for Next.js
 */
function generateSentrySetup(ctx: RepoContext): GeneratedFile[] {
  const isNextJS = ctx.techStack.frameworks.includes('next.js')
  
  if (isNextJS) {
    return [{
      path: 'sentry.client.config.ts',
      content: `// =============================================================================
// SENTRY CLIENT CONFIGURATION
// =============================================================================
// Generated by Orion
// Tracks errors in the browser

import * as Sentry from '@sentry/nextjs'

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  
  // Performance monitoring
  tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,
  
  // Session replay (captures user interactions before crash)
  replaysSessionSampleRate: 0.1,
  replaysOnErrorSampleRate: 1.0,
  
  // Environment
  environment: process.env.NODE_ENV,
  
  // Release tracking
  release: process.env.NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA,
  
  // Filter out noisy errors
  ignoreErrors: [
    'ResizeObserver loop limit exceeded',
    'Non-Error promise rejection',
    /Loading chunk \\d+ failed/,
  ],
  
  // Disable in development
  enabled: process.env.NODE_ENV === 'production',
})
`,
      language: 'typescript',
      category: 'errorHandling',
      confidence: 95,
      description: 'Sentry client-side configuration',
    }, {
      path: 'sentry.server.config.ts',
      content: `// =============================================================================
// SENTRY SERVER CONFIGURATION
// =============================================================================
// Generated by Orion
// Tracks errors on the server

import * as Sentry from '@sentry/nextjs'

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  
  // Performance monitoring
  tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,
  
  // Environment
  environment: process.env.NODE_ENV,
  
  // Release tracking
  release: process.env.VERCEL_GIT_COMMIT_SHA,
  
  // Disable in development
  enabled: process.env.NODE_ENV === 'production',
})
`,
      language: 'typescript',
      category: 'errorHandling',
      confidence: 95,
      description: 'Sentry server-side configuration',
    }, {
      path: 'app/global-error.tsx',
      content: `'use client'

// =============================================================================
// GLOBAL ERROR BOUNDARY
// =============================================================================
// Generated by Orion
// Catches unhandled errors in the root layout

import * as Sentry from '@sentry/nextjs'
import { useEffect } from 'react'

export default function GlobalError({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  useEffect(() => {
    Sentry.captureException(error)
  }, [error])

  return (
    <html>
      <body>
        <div style={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          minHeight: '100vh',
          padding: '2rem',
          fontFamily: 'system-ui, sans-serif',
        }}>
          <h1 style={{ fontSize: '2rem', marginBottom: '1rem' }}>
            Something went wrong
          </h1>
          <p style={{ color: '#666', marginBottom: '2rem' }}>
            We've been notified and are working on a fix.
          </p>
          <button
            onClick={reset}
            style={{
              padding: '0.75rem 1.5rem',
              backgroundColor: '#0070f3',
              color: 'white',
              border: 'none',
              borderRadius: '0.5rem',
              cursor: 'pointer',
              fontSize: '1rem',
            }}
          >
            Try again
          </button>
        </div>
      </body>
    </html>
  )
}
`,
      language: 'typescript',
      category: 'errorHandling',
      confidence: 95,
      description: 'Global error boundary for root layout',
    }]
  }
  
  // Generic Sentry setup for non-Next.js
  return [{
    path: 'lib/sentry.ts',
    content: `// =============================================================================
// SENTRY INITIALIZATION
// =============================================================================
// Generated by Orion

import * as Sentry from '@sentry/node'

export function initSentry() {
  Sentry.init({
    dsn: process.env.SENTRY_DSN,
    tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,
    environment: process.env.NODE_ENV,
    enabled: process.env.NODE_ENV === 'production',
  })
}

export { Sentry }
`,
    language: 'typescript',
    category: 'errorHandling',
    confidence: 90,
    description: 'Sentry initialization',
  }]
}

/**
 * Generate React error boundary component
 */
function generateErrorBoundary(): GeneratedFile {
  return {
    path: 'components/ErrorBoundary.tsx',
    content: `'use client'

// =============================================================================
// ERROR BOUNDARY COMPONENT
// =============================================================================
// Generated by Orion
// Catches JavaScript errors in child component tree

import { Component, ReactNode } from 'react'

interface Props {
  children: ReactNode
  fallback?: ReactNode
  onError?: (error: Error, errorInfo: React.ErrorInfo) => void
}

interface State {
  hasError: boolean
  error: Error | null
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false, error: null }
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('ErrorBoundary caught an error:', error, errorInfo)
    this.props.onError?.(error, errorInfo)
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback
      }
      
      return (
        <div className="error-boundary-fallback" style={{
          padding: '2rem',
          textAlign: 'center',
          backgroundColor: '#fef2f2',
          borderRadius: '0.5rem',
          border: '1px solid #fecaca',
        }}>
          <h2 style={{ color: '#dc2626', marginBottom: '0.5rem' }}>
            Something went wrong
          </h2>
          <p style={{ color: '#7f1d1d' }}>
            {this.state.error?.message || 'An unexpected error occurred'}
          </p>
          <button
            onClick={() => this.setState({ hasError: false, error: null })}
            style={{
              marginTop: '1rem',
              padding: '0.5rem 1rem',
              backgroundColor: '#dc2626',
              color: 'white',
              border: 'none',
              borderRadius: '0.25rem',
              cursor: 'pointer',
            }}
          >
            Try again
          </button>
        </div>
      )
    }

    return this.props.children
  }
}

// Hook for function components
export function useErrorBoundary() {
  const [error, setError] = useState<Error | null>(null)
  
  const resetError = () => setError(null)
  
  const captureError = (error: Error) => {
    setError(error)
    throw error // Re-throw to be caught by boundary
  }
  
  return { error, resetError, captureError }
}

import { useState } from 'react'
`,
    language: 'typescript',
    category: 'errorHandling',
    confidence: 95,
    description: 'React error boundary component',
  }
}

/**
 * Generate structured logger
 */
function generateLogger(): GeneratedFile {
  return {
    path: 'lib/logger.ts',
    content: `// =============================================================================
// STRUCTURED LOGGER
// =============================================================================
// Generated by Orion
// Provides consistent logging with context

type LogLevel = 'debug' | 'info' | 'warn' | 'error'

interface LogContext {
  [key: string]: unknown
}

interface LogEntry {
  timestamp: string
  level: LogLevel
  message: string
  context?: LogContext
}

const LOG_LEVELS: Record<LogLevel, number> = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
}

const MIN_LEVEL = LOG_LEVELS[
  (process.env.LOG_LEVEL as LogLevel) || 'info'
]

function formatEntry(entry: LogEntry): string {
  if (process.env.NODE_ENV === 'production') {
    // JSON format for production (better for log aggregation)
    return JSON.stringify(entry)
  }
  
  // Human-readable format for development
  const contextStr = entry.context 
    ? ' ' + JSON.stringify(entry.context)
    : ''
  return \`[\${entry.timestamp}] \${entry.level.toUpperCase()}: \${entry.message}\${contextStr}\`
}

function log(level: LogLevel, message: string, context?: LogContext) {
  if (LOG_LEVELS[level] < MIN_LEVEL) return
  
  const entry: LogEntry = {
    timestamp: new Date().toISOString(),
    level,
    message,
    context,
  }
  
  const formatted = formatEntry(entry)
  
  switch (level) {
    case 'debug':
    case 'info':
      console.log(formatted)
      break
    case 'warn':
      console.warn(formatted)
      break
    case 'error':
      console.error(formatted)
      break
  }
}

export const logger = {
  debug: (message: string, context?: LogContext) => log('debug', message, context),
  info: (message: string, context?: LogContext) => log('info', message, context),
  warn: (message: string, context?: LogContext) => log('warn', message, context),
  error: (message: string, context?: LogContext) => log('error', message, context),
  
  // Create a child logger with preset context
  child: (baseContext: LogContext) => ({
    debug: (message: string, context?: LogContext) => 
      log('debug', message, { ...baseContext, ...context }),
    info: (message: string, context?: LogContext) => 
      log('info', message, { ...baseContext, ...context }),
    warn: (message: string, context?: LogContext) => 
      log('warn', message, { ...baseContext, ...context }),
    error: (message: string, context?: LogContext) => 
      log('error', message, { ...baseContext, ...context }),
  }),
}

// Usage examples:
// logger.info('User signed in', { userId: '123' })
// logger.error('API call failed', { endpoint: '/api/users', status: 500 })
// 
// const requestLogger = logger.child({ requestId: 'abc123' })
// requestLogger.info('Processing request')
`,
    language: 'typescript',
    category: 'errorHandling',
    confidence: 90,
    description: 'Structured logging utility',
  }
}

/**
 * Generate global error handler for API routes
 */
function generateGlobalErrorHandler(): GeneratedFile {
  return {
    path: 'lib/api-error-handler.ts',
    content: `// =============================================================================
// API ERROR HANDLER
// =============================================================================
// Generated by Orion
// Consistent error handling for API routes

import { NextResponse } from 'next/server'
import { logger } from './logger'

// Custom error classes
export class AppError extends Error {
  constructor(
    message: string,
    public statusCode: number = 500,
    public code?: string
  ) {
    super(message)
    this.name = 'AppError'
  }
}

export class ValidationError extends AppError {
  constructor(message: string, public errors?: Record<string, string[]>) {
    super(message, 400, 'VALIDATION_ERROR')
    this.name = 'ValidationError'
  }
}

export class AuthenticationError extends AppError {
  constructor(message: string = 'Authentication required') {
    super(message, 401, 'AUTHENTICATION_ERROR')
    this.name = 'AuthenticationError'
  }
}

export class AuthorizationError extends AppError {
  constructor(message: string = 'Permission denied') {
    super(message, 403, 'AUTHORIZATION_ERROR')
    this.name = 'AuthorizationError'
  }
}

export class NotFoundError extends AppError {
  constructor(message: string = 'Resource not found') {
    super(message, 404, 'NOT_FOUND')
    this.name = 'NotFoundError'
  }
}

export class RateLimitError extends AppError {
  constructor(public retryAfter: number = 60) {
    super('Too many requests', 429, 'RATE_LIMIT_EXCEEDED')
    this.name = 'RateLimitError'
  }
}

/**
 * Wrap API route handler with error handling
 */
export function withErrorHandler<T>(
  handler: (request: Request, context?: T) => Promise<Response>
) {
  return async (request: Request, context?: T): Promise<Response> => {
    try {
      return await handler(request, context)
    } catch (error) {
      return handleError(error, request)
    }
  }
}

/**
 * Handle and format errors for API responses
 */
export function handleError(error: unknown, request?: Request): Response {
  // Log the error
  const errorDetails = {
    url: request?.url,
    method: request?.method,
    error: error instanceof Error ? error.message : 'Unknown error',
    stack: error instanceof Error ? error.stack : undefined,
  }
  
  if (error instanceof AppError) {
    // Known application errors
    if (error.statusCode >= 500) {
      logger.error('Server error', errorDetails)
    } else {
      logger.warn('Client error', errorDetails)
    }
    
    const response: Record<string, unknown> = {
      error: error.message,
      code: error.code,
    }
    
    if (error instanceof ValidationError && error.errors) {
      response.errors = error.errors
    }
    
    if (error instanceof RateLimitError) {
      return NextResponse.json(response, {
        status: error.statusCode,
        headers: {
          'Retry-After': error.retryAfter.toString(),
        },
      })
    }
    
    return NextResponse.json(response, { status: error.statusCode })
  }
  
  // Unknown errors - don't expose details to client
  logger.error('Unhandled error', errorDetails)
  
  return NextResponse.json(
    { error: 'An unexpected error occurred' },
    { status: 500 }
  )
}
`,
    language: 'typescript',
    category: 'errorHandling',
    confidence: 95,
    description: 'API error handling utilities',
  }
}
