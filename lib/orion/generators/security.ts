// =============================================================================
// SECURITY FIX GENERATORS
// =============================================================================

import { GeneratedFile, Gap, RepoContext } from '../types'

export const SECURITY_TEMPLATES: Record<string, (ctx: RepoContext, gap: Gap) => GeneratedFile[]> = {
  'security-headers': generateSecurityHeaders,
  'encrypt-session': generateEncryptSession,
  'secure-cookies': generateSecureCookies,
  'env-example': generateEnvExample,
  'xss-sanitization': generateXSSSanitization,
  'extract-secret': generateExtractSecret,
}

/**
 * Generate fixes for security gaps
 */
export async function generateSecurityFixes(
  ctx: RepoContext,
  gaps: Gap[]
): Promise<GeneratedFile[]> {
  const files: GeneratedFile[] = []
  
  for (const gap of gaps) {
    if (gap.fixTemplate && SECURITY_TEMPLATES[gap.fixTemplate]) {
      const generated = SECURITY_TEMPLATES[gap.fixTemplate](ctx, gap)
      files.push(...generated)
    }
  }
  
  return files
}

/**
 * Generate security headers for Next.js
 */
function generateSecurityHeaders(ctx: RepoContext): GeneratedFile[] {
  const isNextJS = ctx.techStack.frameworks.includes('next.js')
  
  if (!isNextJS) {
    // Express/Node.js middleware
    return [{
      path: 'src/middleware/security-headers.ts',
      content: `// =============================================================================
// SECURITY HEADERS MIDDLEWARE
// =============================================================================
// Generated by Orion

import { Request, Response, NextFunction } from 'express'

export function securityHeaders(req: Request, res: Response, next: NextFunction) {
  // Prevent clickjacking
  res.setHeader('X-Frame-Options', 'DENY')
  
  // Prevent MIME type sniffing
  res.setHeader('X-Content-Type-Options', 'nosniff')
  
  // Enable XSS filter
  res.setHeader('X-XSS-Protection', '1; mode=block')
  
  // Enforce HTTPS
  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains')
  
  // Referrer policy
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin')
  
  // Permissions policy
  res.setHeader('Permissions-Policy', 'camera=(), microphone=(), geolocation=()')
  
  // Content Security Policy
  res.setHeader('Content-Security-Policy', [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline' 'unsafe-eval'",
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' data: https:",
    "font-src 'self' data:",
    "connect-src 'self' https:",
  ].join('; '))
  
  next()
}

// Usage: app.use(securityHeaders)
`,
      language: 'typescript',
      category: 'security',
      confidence: 95,
      description: 'Security headers middleware for Express/Node.js',
    }]
  }
  
  // Next.js headers config
  return [{
    path: 'next.config.security.ts',
    content: `// =============================================================================
// SECURITY HEADERS FOR NEXT.JS
// =============================================================================
// Generated by Orion
// Merge this into your next.config.ts headers() function

import { NextConfig } from 'next'

const securityHeaders = [
  {
    key: 'X-DNS-Prefetch-Control',
    value: 'on',
  },
  {
    key: 'Strict-Transport-Security',
    value: 'max-age=63072000; includeSubDomains; preload',
  },
  {
    key: 'X-Frame-Options',
    value: 'DENY',
  },
  {
    key: 'X-Content-Type-Options',
    value: 'nosniff',
  },
  {
    key: 'X-XSS-Protection',
    value: '1; mode=block',
  },
  {
    key: 'Referrer-Policy',
    value: 'strict-origin-when-cross-origin',
  },
  {
    key: 'Permissions-Policy',
    value: 'camera=(), microphone=(), geolocation=()',
  },
]

export const securityConfig: Partial<NextConfig> = {
  async headers() {
    return [
      {
        source: '/:path*',
        headers: securityHeaders,
      },
    ]
  },
}

// To use, merge with your existing next.config.ts:
// 
// import { securityConfig } from './next.config.security'
// 
// const nextConfig = {
//   ...securityConfig,
//   // your other config
// }
`,
    language: 'typescript',
    category: 'security',
    confidence: 95,
    description: 'Security headers configuration for Next.js',
  }]
}

/**
 * Generate encryption module for session data
 */
function generateEncryptSession(): GeneratedFile[] {
  return [{
    path: 'src/lib/crypto.ts',
    content: `// =============================================================================
// ENCRYPTION UTILITIES - AES-256-GCM
// =============================================================================
// Generated by Orion for secure session handling

import { 
  createCipheriv, 
  createDecipheriv, 
  randomBytes, 
  scryptSync, 
  timingSafeEqual 
} from 'crypto'

const ALGORITHM = 'aes-256-gcm'
const IV_LENGTH = 16
const TAG_LENGTH = 16
const SALT_LENGTH = 64
const KEY_LENGTH = 32

function getKey(secret: string, salt: Buffer): Buffer {
  return scryptSync(secret, salt, KEY_LENGTH)
}

/**
 * Encrypt text using AES-256-GCM with a random salt and IV.
 * Output format: salt:iv:ciphertext:authTag (all hex encoded)
 */
export async function encrypt(text: string): Promise<string> {
  const secret = process.env.ENCRYPTION_SECRET
  if (!secret) {
    throw new Error('ENCRYPTION_SECRET is not set')
  }
  if (secret.length < 32) {
    throw new Error('ENCRYPTION_SECRET must be at least 32 characters')
  }

  const salt = randomBytes(SALT_LENGTH)
  const key = getKey(secret, salt)
  const iv = randomBytes(IV_LENGTH)
  const cipher = createCipheriv(ALGORITHM, key, iv)

  let encrypted = cipher.update(text, 'utf8', 'hex')
  encrypted += cipher.final('hex')
  const tag = cipher.getAuthTag()

  return \`\${salt.toString('hex')}:\${iv.toString('hex')}:\${encrypted}:\${tag.toString('hex')}\`
}

/**
 * Decrypt text encrypted with the encrypt function.
 * Throws if decryption fails (wrong key, tampered data, etc.)
 */
export async function decrypt(encryptedText: string): Promise<string> {
  const secret = process.env.ENCRYPTION_SECRET
  if (!secret) {
    throw new Error('ENCRYPTION_SECRET is not set')
  }

  const parts = encryptedText.split(':')
  if (parts.length !== 4) {
    throw new Error('Invalid encrypted text format')
  }

  const [saltHex, ivHex, encrypted, tagHex] = parts
  const salt = Buffer.from(saltHex, 'hex')
  const iv = Buffer.from(ivHex, 'hex')
  const tag = Buffer.from(tagHex, 'hex')
  const key = getKey(secret, salt)

  const decipher = createDecipheriv(ALGORITHM, key, iv)
  decipher.setAuthTag(tag)

  let decrypted = decipher.update(encrypted, 'hex', 'utf8')
  decrypted += decipher.final('utf8')

  return decrypted
}

/**
 * Constant-time string comparison to prevent timing attacks
 */
export function secureCompare(a: string, b: string): boolean {
  if (a.length !== b.length) return false
  const bufA = Buffer.from(a)
  const bufB = Buffer.from(b)
  return timingSafeEqual(bufA, bufB)
}

/**
 * Generate a secure random token
 */
export function generateToken(length: number = 32): string {
  return randomBytes(length).toString('hex')
}

/**
 * Hash a value for non-reversible storage (use bcrypt for passwords)
 */
export function hashValue(value: string): string {
  const salt = randomBytes(16).toString('hex')
  const hash = scryptSync(value, salt, 64).toString('hex')
  return \`\${salt}:\${hash}\`
}

/**
 * Verify a hashed value
 */
export function verifyHash(value: string, storedHash: string): boolean {
  const [salt, hash] = storedHash.split(':')
  const compareHash = scryptSync(value, salt, 64).toString('hex')
  return secureCompare(hash, compareHash)
}
`,
    language: 'typescript',
    category: 'security',
    confidence: 98,
    description: 'AES-256-GCM encryption module for session data',
  }, {
    path: 'tests/security/crypto.test.ts',
    content: `// =============================================================================
// ENCRYPTION TESTS
// =============================================================================

import { describe, it, expect, beforeAll } from 'vitest'
import { encrypt, decrypt, secureCompare, generateToken, hashValue, verifyHash } from '@/lib/crypto'

describe('Encryption Module', () => {
  beforeAll(() => {
    process.env.ENCRYPTION_SECRET = 'test-secret-key-that-is-at-least-32-characters-long'
  })

  describe('encrypt/decrypt', () => {
    it('should encrypt and decrypt text correctly', async () => {
      const original = 'Hello, World!'
      const encrypted = await encrypt(original)
      const decrypted = await decrypt(encrypted)
      
      expect(decrypted).toBe(original)
    })

    it('should produce different ciphertext for same plaintext', async () => {
      const text = 'Same text'
      const encrypted1 = await encrypt(text)
      const encrypted2 = await encrypt(text)
      
      expect(encrypted1).not.toBe(encrypted2)
    })

    it('should handle special characters', async () => {
      const special = '{"user": "test", "token": "abc123", "emoji": "ðŸ”"}'
      const encrypted = await encrypt(special)
      const decrypted = await decrypt(encrypted)
      
      expect(decrypted).toBe(special)
    })

    it('should throw on invalid encrypted text', async () => {
      await expect(decrypt('invalid')).rejects.toThrow()
    })
  })

  describe('secureCompare', () => {
    it('should return true for equal strings', () => {
      expect(secureCompare('abc', 'abc')).toBe(true)
    })

    it('should return false for different strings', () => {
      expect(secureCompare('abc', 'abd')).toBe(false)
    })

    it('should return false for different lengths', () => {
      expect(secureCompare('abc', 'abcd')).toBe(false)
    })
  })

  describe('generateToken', () => {
    it('should generate token of correct length', () => {
      const token = generateToken(16)
      expect(token).toHaveLength(32) // hex encoding doubles length
    })

    it('should generate unique tokens', () => {
      const token1 = generateToken()
      const token2 = generateToken()
      expect(token1).not.toBe(token2)
    })
  })

  describe('hashValue/verifyHash', () => {
    it('should hash and verify correctly', () => {
      const value = 'my-secret-value'
      const hashed = hashValue(value)
      
      expect(verifyHash(value, hashed)).toBe(true)
      expect(verifyHash('wrong-value', hashed)).toBe(false)
    })
  })
})
`,
    language: 'typescript',
    category: 'testing',
    confidence: 95,
    description: 'Tests for encryption module',
  }]
}

/**
 * Generate secure cookie configuration
 */
function generateSecureCookies(): GeneratedFile[] {
  return [{
    path: 'src/lib/cookies.ts',
    content: `// =============================================================================
// SECURE COOKIE CONFIGURATION
// =============================================================================
// Generated by Orion

import { ResponseCookie } from 'next/dist/compiled/@edge-runtime/cookies'

/**
 * Secure cookie options for production
 */
export const SECURE_COOKIE_OPTIONS: Partial<ResponseCookie> = {
  httpOnly: true, // Prevents JavaScript access (XSS protection)
  secure: process.env.NODE_ENV === 'production', // HTTPS only in production
  sameSite: 'lax', // CSRF protection (use 'strict' for highest security)
  path: '/',
  maxAge: 60 * 60 * 24, // 24 hours (consider shorter for sensitive apps)
}

/**
 * Extra-secure options for sensitive data (e.g., session tokens)
 */
export const SENSITIVE_COOKIE_OPTIONS: Partial<ResponseCookie> = {
  ...SECURE_COOKIE_OPTIONS,
  sameSite: 'strict', // Stricter CSRF protection
  maxAge: 60 * 60 * 4, // 4 hours
}

/**
 * Set a secure cookie
 */
export function createSecureCookie(
  name: string,
  value: string,
  options: Partial<ResponseCookie> = {}
): ResponseCookie {
  return {
    name,
    value,
    ...SECURE_COOKIE_OPTIONS,
    ...options,
  }
}

/**
 * Cookie names - centralized for consistency
 */
export const COOKIE_NAMES = {
  session: '__session',
  csrf: '__csrf',
  auth: '__auth',
  preferences: 'preferences',
} as const
`,
    language: 'typescript',
    category: 'security',
    confidence: 95,
    description: 'Secure cookie configuration',
  }]
}

/**
 * Generate .env.example file
 */
function generateEnvExample(ctx: RepoContext): GeneratedFile[] {
  const envVars: string[] = [
    '# =============================================================================',
    '# ENVIRONMENT VARIABLES',
    '# =============================================================================',
    '# Copy this file to .env.local and fill in your values',
    '# Generated by Orion',
    '',
    '# App',
    'NEXT_PUBLIC_APP_URL=http://localhost:3000',
    '',
  ]
  
  // Detect what's needed from package.json
  const deps = ctx.packageJson ? {
    ...((ctx.packageJson.dependencies as Record<string, string>) || {}),
    ...((ctx.packageJson.devDependencies as Record<string, string>) || {})
  } : {}
  
  // Database
  if (ctx.techStack.database) {
    envVars.push('# Database')
    envVars.push('DATABASE_URL=postgresql://user:password@localhost:5432/dbname')
    envVars.push('')
  }
  
  // Auth
  if (deps['next-auth']) {
    envVars.push('# NextAuth')
    envVars.push('NEXTAUTH_URL=http://localhost:3000')
    envVars.push('NEXTAUTH_SECRET=your-secret-here-generate-with-openssl-rand-base64-32')
    envVars.push('')
  }
  
  // OAuth
  if (ctx.files.some(f => f.content.includes('GITHUB_CLIENT'))) {
    envVars.push('# GitHub OAuth')
    envVars.push('GITHUB_CLIENT_ID=')
    envVars.push('GITHUB_CLIENT_SECRET=')
    envVars.push('')
  }
  
  // Stripe
  if (deps['stripe']) {
    envVars.push('# Stripe')
    envVars.push('STRIPE_SECRET_KEY=sk_test_...')
    envVars.push('STRIPE_WEBHOOK_SECRET=whsec_...')
    envVars.push('NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_...')
    envVars.push('')
  }
  
  // AI
  if (deps['openai'] || deps['@anthropic-ai/sdk']) {
    envVars.push('# AI')
    if (deps['openai']) envVars.push('OPENAI_API_KEY=sk-...')
    if (deps['@anthropic-ai/sdk']) envVars.push('ANTHROPIC_API_KEY=sk-ant-...')
    envVars.push('')
  }
  
  // Security
  envVars.push('# Security')
  envVars.push('ENCRYPTION_SECRET=generate-with-openssl-rand-base64-32')
  envVars.push('')
  
  return [{
    path: '.env.example',
    content: envVars.join('\n'),
    language: 'plaintext',
    category: 'security',
    confidence: 90,
    description: 'Environment variables documentation',
  }]
}

/**
 * Generate XSS sanitization utilities
 */
function generateXSSSanitization(): GeneratedFile[] {
  return [{
    path: 'src/lib/sanitize.ts',
    content: `// =============================================================================
// XSS SANITIZATION UTILITIES
// =============================================================================
// Generated by Orion

/**
 * Escape HTML entities to prevent XSS
 */
export function escapeHtml(str: string): string {
  const htmlEscapes: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '/': '&#x2F;',
  }
  return str.replace(/[&<>"'/]/g, (char) => htmlEscapes[char])
}

/**
 * Sanitize HTML for safe rendering
 * For full HTML sanitization, consider using DOMPurify:
 * npm install dompurify @types/dompurify
 */
export function sanitizeHtml(html: string): string {
  // Remove script tags and event handlers
  return html
    .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '')
    .replace(/on\\w+="[^"]*"/gi, '')
    .replace(/on\\w+='[^']*'/gi, '')
    .replace(/javascript:/gi, '')
}

/**
 * Sanitize a URL to prevent javascript: and data: protocols
 */
export function sanitizeUrl(url: string): string {
  const parsed = url.trim().toLowerCase()
  
  // Block dangerous protocols
  if (
    parsed.startsWith('javascript:') ||
    parsed.startsWith('data:') ||
    parsed.startsWith('vbscript:')
  ) {
    return '#'
  }
  
  // Ensure proper protocol for absolute URLs
  if (parsed.startsWith('//')) {
    return \`https:\${url}\`
  }
  
  return url
}

/**
 * Safe JSON parse with type validation
 */
export function safeJsonParse<T>(
  json: string,
  fallback: T
): T {
  try {
    return JSON.parse(json) as T
  } catch {
    return fallback
  }
}

/**
 * Strip all HTML tags
 */
export function stripHtml(html: string): string {
  return html.replace(/<[^>]*>/g, '')
}
`,
    language: 'typescript',
    category: 'security',
    confidence: 92,
    description: 'XSS sanitization utilities',
  }]
}

/**
 * Generate instructions for extracting hardcoded secrets
 */
function generateExtractSecret(_ctx: RepoContext, gap: Gap): GeneratedFile[] {
  return [{
    path: '.orion/fixes/extract-secret-guide.md',
    content: `# Fix: Extract Hardcoded Secret

## Issue
Found in: \`${gap.file || 'unknown'}\`

A hardcoded secret was detected in your source code. This is a security risk
because anyone with access to your code can see the secret.

## How to Fix

1. **Remove the hardcoded value** from your code
2. **Add it to your .env.local** file:
   \`\`\`
   MY_SECRET_KEY=your-actual-value
   \`\`\`

3. **Update your code** to use the environment variable:
   \`\`\`typescript
   // Before
   const apiKey = "sk-..."
   
   // After
   const apiKey = process.env.MY_SECRET_KEY
   \`\`\`

4. **Add the variable name** to .env.example (without the actual value):
   \`\`\`
   MY_SECRET_KEY=your-key-here
   \`\`\`

5. **Rotate the secret** - Since it was exposed in your code, generate a new key
   from your service provider.

## Prevention

- Never hardcode secrets, even in "test" code
- Use environment variables from the start
- Add secret scanning to your CI pipeline
`,
    language: 'markdown',
    category: 'security',
    confidence: 100,
    description: 'Guide for extracting hardcoded secrets',
  }]
}

