// =============================================================================
// DATABASE GENERATION
// =============================================================================

import { GeneratedFile, Gap, RepoContext } from '../types'

/**
 * Generate database fixes for identified gaps
 */
export async function generateDatabase(
  ctx: RepoContext,
  gaps: Gap[]
): Promise<GeneratedFile[]> {
  const files: GeneratedFile[] = []
  
  // Generate Prisma schema if no ORM
  const noORM = gaps.find(g => g.id === 'database-no-orm')
  if (noORM) {
    files.push(...generatePrismaSetup(ctx))
  }
  
  // Generate connection pooling if missing
  const noPooling = gaps.find(g => g.id === 'database-no-pooling')
  if (noPooling) {
    files.push(generateConnectionPooling())
  }
  
  // Generate backup strategy docs
  const noBackups = gaps.find(g => g.id === 'database-no-backups')
  if (noBackups) {
    files.push(generateBackupStrategy())
  }
  
  return files
}

/**
 * Generate Prisma setup files
 */
function generatePrismaSetup(ctx: RepoContext): GeneratedFile[] {
  return [{
    path: 'prisma/schema.prisma',
    content: `// =============================================================================
// PRISMA SCHEMA
// =============================================================================
// Generated by Orion
// Learn more: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_URL_UNPOOLED")
}

// =============================================================================
// USER MODEL - Core user entity
// =============================================================================

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  image     String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Add your relations here
  // posts     Post[]
  // comments  Comment[]
}

// =============================================================================
// SESSION MODEL - For authentication (if not using external auth)
// =============================================================================

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Add more models as needed
`,
    language: 'prisma',
    category: 'database',
    confidence: 90,
    description: 'Prisma schema with User model',
  }, {
    path: 'lib/prisma.ts',
    content: `// =============================================================================
// PRISMA CLIENT SINGLETON
// =============================================================================
// Generated by Orion
// Prevents multiple Prisma instances in development

import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient({
  log: process.env.NODE_ENV === 'development' 
    ? ['query', 'error', 'warn'] 
    : ['error'],
})

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma
}
`,
    language: 'typescript',
    category: 'database',
    confidence: 95,
    description: 'Prisma client singleton',
  }]
}

/**
 * Generate connection pooling configuration
 */
function generateConnectionPooling(): GeneratedFile {
  return {
    path: 'lib/db-pool.ts',
    content: `// =============================================================================
// DATABASE CONNECTION POOLING
// =============================================================================
// Generated by Orion
// Optimized connection management for serverless environments

import { PrismaClient } from '@prisma/client'

// Connection pool configuration
const POOL_CONFIG = {
  // Maximum number of connections in the pool
  connectionLimit: parseInt(process.env.DB_POOL_SIZE || '10'),
  
  // Maximum time to wait for a connection (ms)
  connectTimeout: parseInt(process.env.DB_CONNECT_TIMEOUT || '10000'),
  
  // Keep connections alive with periodic pings
  idleTimeoutMs: parseInt(process.env.DB_IDLE_TIMEOUT || '60000'),
}

// For serverless (Vercel, AWS Lambda), use connection pooling service
// Options:
// 1. Prisma Accelerate (prisma.io/accelerate)
// 2. PgBouncer
// 3. Neon connection pooler (built-in)
// 4. Supabase pooler (built-in)

/**
 * Prisma with query extensions for monitoring
 */
export const db = new PrismaClient({
  log: [
    { emit: 'event', level: 'query' },
    { emit: 'event', level: 'error' },
    { emit: 'event', level: 'warn' },
  ],
}).$extends({
  query: {
    async $allOperations({ operation, model, args, query }) {
      const start = performance.now()
      const result = await query(args)
      const duration = performance.now() - start
      
      // Log slow queries (> 1000ms)
      if (duration > 1000) {
        console.warn(\`Slow query: \${model}.\${operation} took \${duration.toFixed(2)}ms\`)
      }
      
      return result
    },
  },
})

/**
 * Healthcheck for database connection
 */
export async function checkDatabaseHealth(): Promise<{
  healthy: boolean
  latencyMs: number
  error?: string
}> {
  const start = performance.now()
  
  try {
    await db.$queryRaw\`SELECT 1\`
    return {
      healthy: true,
      latencyMs: Math.round(performance.now() - start),
    }
  } catch (error) {
    return {
      healthy: false,
      latencyMs: Math.round(performance.now() - start),
      error: error instanceof Error ? error.message : 'Unknown error',
    }
  }
}

// Graceful shutdown
process.on('beforeExit', async () => {
  await db.$disconnect()
})
`,
    language: 'typescript',
    category: 'database',
    confidence: 85,
    description: 'Connection pooling and health checks',
  }
}

/**
 * Generate backup strategy documentation
 */
function generateBackupStrategy(): GeneratedFile {
  return {
    path: 'docs/database-backup.md',
    content: `# Database Backup Strategy

Generated by Orion

## Recommended Approach

### For Managed Databases (Neon, Supabase, PlanetScale)

These services include automatic backups. Check your dashboard for:
- Point-in-time recovery
- Daily snapshots
- Retention period (usually 7-30 days)

### For Self-Hosted PostgreSQL

#### 1. Automated Daily Backups

\`\`\`bash
#!/bin/bash
# backup.sh - Run via cron daily

BACKUP_DIR="/backups"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/db_backup_$TIMESTAMP.sql.gz"

pg_dump $DATABASE_URL | gzip > $BACKUP_FILE

# Upload to S3/GCS
aws s3 cp $BACKUP_FILE s3://your-bucket/backups/

# Keep only last 30 days locally
find $BACKUP_DIR -name "db_backup_*.sql.gz" -mtime +30 -delete
\`\`\`

#### 2. Cron Schedule

\`\`\`cron
# Daily at 2 AM
0 2 * * * /path/to/backup.sh
\`\`\`

#### 3. Test Restores Monthly

\`\`\`bash
# Restore to test database
gunzip -c backup.sql.gz | psql $TEST_DATABASE_URL
\`\`\`

## Disaster Recovery Checklist

- [ ] Backups stored in different region than production
- [ ] Backup encryption enabled
- [ ] Restore process documented and tested
- [ ] Recovery time objective (RTO) defined
- [ ] Recovery point objective (RPO) defined
- [ ] Team members trained on restore process
`,
    language: 'markdown',
    category: 'database',
    confidence: 80,
    description: 'Database backup strategy guide',
  }
}
