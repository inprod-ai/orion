// =============================================================================
// AUTHENTICATION GENERATION
// =============================================================================

import { GeneratedFile, Gap, RepoContext } from '../types'

/**
 * Generate authentication fixes for identified gaps
 */
export async function generateAuthentication(
  ctx: RepoContext,
  gaps: Gap[]
): Promise<GeneratedFile[]> {
  const files: GeneratedFile[] = []
  
  // Generate session encryption if missing
  const noEncryption = gaps.find(g => g.id === 'auth-no-encryption')
  if (noEncryption) {
    files.push(generateCryptoUtils())
  }
  
  // Generate CSRF protection if missing
  const noCSRF = gaps.find(g => g.id === 'auth-no-csrf')
  if (noCSRF) {
    files.push(generateCSRFProtection())
  }
  
  // Generate secure cookies if missing
  const noSecureCookies = gaps.find(g => g.id === 'auth-no-secure-cookies')
  if (noSecureCookies) {
    files.push(generateSecureCookies())
  }
  
  // Generate rate limiting for auth routes
  const noRateLimit = gaps.find(g => g.id === 'auth-no-rate-limit')
  if (noRateLimit) {
    files.push(generateAuthRateLimiting())
  }
  
  return files
}

/**
 * Generate crypto utilities for session encryption
 */
function generateCryptoUtils(): GeneratedFile {
  return {
    path: 'lib/crypto.ts',
    content: `// =============================================================================
// CRYPTO UTILITIES - AES-256-GCM Encryption/Decryption
// =============================================================================
// Generated by Orion
// Provides secure encryption for session tokens and sensitive data

import { createCipheriv, createDecipheriv, randomBytes, scryptSync } from 'crypto'

const ALGORITHM = 'aes-256-gcm'
const IV_LENGTH = 16
const TAG_LENGTH = 16
const SALT_LENGTH = 64
const KEY_LENGTH = 32

/**
 * Encrypt a string using AES-256-GCM
 * Returns: salt:iv:encrypted:tag (hex encoded)
 */
export async function encrypt(text: string): Promise<string> {
  const secret = process.env.ENCRYPTION_SECRET
  if (!secret || secret.length < 32) {
    throw new Error('ENCRYPTION_SECRET must be at least 32 characters')
  }
  
  const salt = randomBytes(SALT_LENGTH)
  const key = scryptSync(secret, salt, KEY_LENGTH)
  const iv = randomBytes(IV_LENGTH)
  const cipher = createCipheriv(ALGORITHM, key, iv)
  
  let encrypted = cipher.update(text, 'utf8', 'hex')
  encrypted += cipher.final('hex')
  const tag = cipher.getAuthTag()
  
  return \`\${salt.toString('hex')}:\${iv.toString('hex')}:\${encrypted}:\${tag.toString('hex')}\`
}

/**
 * Decrypt a string encrypted with encrypt()
 */
export async function decrypt(encryptedText: string): Promise<string> {
  const secret = process.env.ENCRYPTION_SECRET
  if (!secret) throw new Error('ENCRYPTION_SECRET not set')
  
  const [saltHex, ivHex, encrypted, tagHex] = encryptedText.split(':')
  if (!saltHex || !ivHex || !encrypted || !tagHex) {
    throw new Error('Invalid encrypted text format')
  }
  
  const salt = Buffer.from(saltHex, 'hex')
  const iv = Buffer.from(ivHex, 'hex')
  const tag = Buffer.from(tagHex, 'hex')
  const key = scryptSync(secret, salt, KEY_LENGTH)
  
  const decipher = createDecipheriv(ALGORITHM, key, iv)
  decipher.setAuthTag(tag)
  
  let decrypted = decipher.update(encrypted, 'hex', 'utf8')
  decrypted += decipher.final('utf8')
  
  return decrypted
}

/**
 * Generate a secure random token
 */
export function generateToken(length: number = 32): string {
  return randomBytes(length).toString('hex')
}
`,
    language: 'typescript',
    category: 'authentication',
    confidence: 95,
    description: 'AES-256-GCM encryption utilities for session management',
  }
}

/**
 * Generate CSRF protection middleware
 */
function generateCSRFProtection(): GeneratedFile {
  return {
    path: 'lib/csrf.ts',
    content: `// =============================================================================
// CSRF PROTECTION
// =============================================================================
// Generated by Orion
// Provides CSRF token generation and validation

import { cookies } from 'next/headers'
import { randomBytes } from 'crypto'

const CSRF_COOKIE_NAME = 'csrf_token'
const CSRF_HEADER_NAME = 'x-csrf-token'

/**
 * Generate and set a CSRF token cookie
 */
export async function generateCSRFToken(): Promise<string> {
  const token = randomBytes(32).toString('hex')
  const cookieStore = cookies()
  
  cookieStore.set(CSRF_COOKIE_NAME, token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 60 * 60, // 1 hour
  })
  
  return token
}

/**
 * Validate CSRF token from request headers against cookie
 */
export async function validateCSRFToken(request: Request): Promise<boolean> {
  const cookieStore = cookies()
  const cookieToken = cookieStore.get(CSRF_COOKIE_NAME)?.value
  const headerToken = request.headers.get(CSRF_HEADER_NAME)
  
  if (!cookieToken || !headerToken) {
    return false
  }
  
  // Constant-time comparison to prevent timing attacks
  if (cookieToken.length !== headerToken.length) {
    return false
  }
  
  let result = 0
  for (let i = 0; i < cookieToken.length; i++) {
    result |= cookieToken.charCodeAt(i) ^ headerToken.charCodeAt(i)
  }
  
  return result === 0
}

/**
 * CSRF validation middleware for API routes
 */
export async function requireCSRF(request: Request): Promise<Response | null> {
  // Skip for GET, HEAD, OPTIONS
  if (['GET', 'HEAD', 'OPTIONS'].includes(request.method)) {
    return null
  }
  
  const isValid = await validateCSRFToken(request)
  if (!isValid) {
    return new Response(JSON.stringify({ error: 'Invalid CSRF token' }), {
      status: 403,
      headers: { 'Content-Type': 'application/json' },
    })
  }
  
  return null
}
`,
    language: 'typescript',
    category: 'authentication',
    confidence: 90,
    description: 'CSRF token generation and validation',
  }
}

/**
 * Generate secure cookie utilities
 */
function generateSecureCookies(): GeneratedFile {
  return {
    path: 'lib/secure-cookies.ts',
    content: `// =============================================================================
// SECURE COOKIES
// =============================================================================
// Generated by Orion
// Provides secure cookie management for sessions

import { cookies, headers } from 'next/headers'
import { encrypt, decrypt } from './crypto'

const SESSION_COOKIE_NAME = 'session'
const SESSION_MAX_AGE = 60 * 60 * 24 // 24 hours

export interface SessionData {
  userId: string
  expiresAt: number
  [key: string]: unknown
}

/**
 * Set an encrypted session cookie
 */
export async function setSession(data: Omit<SessionData, 'expiresAt'>): Promise<void> {
  const cookieStore = cookies()
  
  const sessionData: SessionData = {
    ...data,
    expiresAt: Date.now() + SESSION_MAX_AGE * 1000,
  }
  
  const encrypted = await encrypt(JSON.stringify(sessionData))
  
  cookieStore.set(SESSION_COOKIE_NAME, encrypted, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: SESSION_MAX_AGE,
    path: '/',
  })
}

/**
 * Get and decrypt session from cookie
 */
export async function getSession(): Promise<SessionData | null> {
  const cookieStore = cookies()
  const encryptedSession = cookieStore.get(SESSION_COOKIE_NAME)?.value
  
  if (!encryptedSession) {
    return null
  }
  
  try {
    const decrypted = await decrypt(encryptedSession)
    const session: SessionData = JSON.parse(decrypted)
    
    // Check expiration
    if (session.expiresAt < Date.now()) {
      await clearSession()
      return null
    }
    
    return session
  } catch (error) {
    console.error('Session decryption failed:', error)
    await clearSession()
    return null
  }
}

/**
 * Clear the session cookie
 */
export async function clearSession(): Promise<void> {
  const cookieStore = cookies()
  cookieStore.delete(SESSION_COOKIE_NAME)
}
`,
    language: 'typescript',
    category: 'authentication',
    confidence: 95,
    description: 'Encrypted session cookie management',
  }
}

/**
 * Generate rate limiting for auth routes
 */
function generateAuthRateLimiting(): GeneratedFile {
  return {
    path: 'lib/rate-limit.ts',
    content: `// =============================================================================
// RATE LIMITING
// =============================================================================
// Generated by Orion
// In-memory rate limiting for auth routes (use Redis for production scale)

interface RateLimitEntry {
  count: number
  resetAt: number
}

const store = new Map<string, RateLimitEntry>()

// Cleanup old entries every 5 minutes
setInterval(() => {
  const now = Date.now()
  for (const [key, entry] of store.entries()) {
    if (entry.resetAt < now) {
      store.delete(key)
    }
  }
}, 5 * 60 * 1000)

export interface RateLimitConfig {
  maxRequests: number      // Max requests per window
  windowMs: number         // Time window in milliseconds
  message?: string         // Custom error message
}

export interface RateLimitResult {
  success: boolean
  remaining: number
  resetAt: number
}

/**
 * Check rate limit for a given key (e.g., IP address or user ID)
 */
export function checkRateLimit(
  key: string,
  config: RateLimitConfig
): RateLimitResult {
  const now = Date.now()
  const entry = store.get(key)
  
  // If no entry or expired, create new one
  if (!entry || entry.resetAt < now) {
    const newEntry: RateLimitEntry = {
      count: 1,
      resetAt: now + config.windowMs,
    }
    store.set(key, newEntry)
    
    return {
      success: true,
      remaining: config.maxRequests - 1,
      resetAt: newEntry.resetAt,
    }
  }
  
  // Check if limit exceeded
  if (entry.count >= config.maxRequests) {
    return {
      success: false,
      remaining: 0,
      resetAt: entry.resetAt,
    }
  }
  
  // Increment counter
  entry.count++
  store.set(key, entry)
  
  return {
    success: true,
    remaining: config.maxRequests - entry.count,
    resetAt: entry.resetAt,
  }
}

/**
 * Rate limit middleware for Next.js API routes
 */
export function createRateLimiter(config: RateLimitConfig) {
  return function rateLimit(request: Request): Response | null {
    // Get IP from headers
    const forwarded = request.headers.get('x-forwarded-for')
    const ip = forwarded?.split(',')[0].trim() || 'unknown'
    
    const result = checkRateLimit(ip, config)
    
    if (!result.success) {
      return new Response(
        JSON.stringify({
          error: config.message || 'Too many requests',
          retryAfter: Math.ceil((result.resetAt - Date.now()) / 1000),
        }),
        {
          status: 429,
          headers: {
            'Content-Type': 'application/json',
            'X-RateLimit-Limit': config.maxRequests.toString(),
            'X-RateLimit-Remaining': '0',
            'X-RateLimit-Reset': result.resetAt.toString(),
            'Retry-After': Math.ceil((result.resetAt - Date.now()) / 1000).toString(),
          },
        }
      )
    }
    
    return null
  }
}

// Pre-configured limiters for common use cases
export const authLimiter = createRateLimiter({
  maxRequests: 5,
  windowMs: 60 * 1000, // 5 requests per minute
  message: 'Too many login attempts. Please try again later.',
})

export const apiLimiter = createRateLimiter({
  maxRequests: 100,
  windowMs: 60 * 1000, // 100 requests per minute
  message: 'Rate limit exceeded.',
})
`,
    language: 'typescript',
    category: 'authentication',
    confidence: 90,
    description: 'Rate limiting for authentication routes',
  }
}
