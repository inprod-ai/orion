// =============================================================================
// BACKEND GENERATION
// =============================================================================

import { GeneratedFile, Gap, RepoContext } from '../types'

/**
 * Generate backend fixes for identified gaps
 */
export async function generateBackend(
  ctx: RepoContext,
  gaps: Gap[]
): Promise<GeneratedFile[]> {
  const files: GeneratedFile[] = []
  
  // Generate Zod validation if missing
  const noValidation = gaps.find(g => g.id === 'backend-no-validation')
  if (noValidation) {
    files.push(generateZodValidation())
  }
  
  // Generate rate limiter if missing
  const noRateLimit = gaps.find(g => g.id === 'backend-no-rate-limit')
  if (noRateLimit) {
    files.push(generateRateLimiter())
  }
  
  // Generate health endpoint if missing
  const noHealth = gaps.find(g => g.id === 'backend-no-health')
  if (noHealth) {
    files.push(generateHealthEndpoint(ctx))
  }
  
  // Generate structured logging if missing
  const noLogging = gaps.find(g => g.id === 'backend-no-logging')
  if (noLogging) {
    files.push(generateApiLogger())
  }
  
  return files
}

/**
 * Generate Zod validation utilities
 */
function generateZodValidation(): GeneratedFile {
  return {
    path: 'lib/validation.ts',
    content: `// =============================================================================
// ZOD VALIDATION UTILITIES
// =============================================================================
// Generated by inprod.ai
// Type-safe request validation for API routes

import { z, ZodError, ZodSchema } from 'zod'
import { NextRequest, NextResponse } from 'next/server'

/**
 * Validate request body against a Zod schema
 */
export async function validateBody<T>(
  request: NextRequest,
  schema: ZodSchema<T>
): Promise<{ data: T } | { error: NextResponse }> {
  try {
    const body = await request.json()
    const data = schema.parse(body)
    return { data }
  } catch (error) {
    if (error instanceof ZodError) {
      return {
        error: NextResponse.json(
          {
            error: 'Validation failed',
            issues: error.issues.map(issue => ({
              path: issue.path.join('.'),
              message: issue.message,
            })),
          },
          { status: 400 }
        ),
      }
    }
    
    if (error instanceof SyntaxError) {
      return {
        error: NextResponse.json(
          { error: 'Invalid JSON in request body' },
          { status: 400 }
        ),
      }
    }
    
    throw error
  }
}

/**
 * Validate query parameters against a Zod schema
 */
export function validateQuery<T>(
  request: NextRequest,
  schema: ZodSchema<T>
): { data: T } | { error: NextResponse } {
  try {
    const params = Object.fromEntries(request.nextUrl.searchParams)
    const data = schema.parse(params)
    return { data }
  } catch (error) {
    if (error instanceof ZodError) {
      return {
        error: NextResponse.json(
          {
            error: 'Invalid query parameters',
            issues: error.issues.map(issue => ({
              path: issue.path.join('.'),
              message: issue.message,
            })),
          },
          { status: 400 }
        ),
      }
    }
    throw error
  }
}

// =============================================================================
// COMMON SCHEMAS
// =============================================================================

export const schemas = {
  // Pagination
  pagination: z.object({
    page: z.coerce.number().int().positive().default(1),
    limit: z.coerce.number().int().min(1).max(100).default(20),
  }),
  
  // ID parameter
  id: z.object({
    id: z.string().min(1),
  }),
  
  // Email
  email: z.string().email(),
  
  // URL
  url: z.string().url(),
  
  // UUID
  uuid: z.string().uuid(),
  
  // GitHub URL
  githubUrl: z.string().url().regex(
    /^https:\\/\\/github\\.com\\/[a-zA-Z0-9_-]+\\/[a-zA-Z0-9_.-]+\\/?$/,
    'Must be a valid GitHub repository URL'
  ),
}

// Usage example:
// const UserSchema = z.object({
//   email: schemas.email,
//   name: z.string().min(1).max(100),
// })
//
// export async function POST(request: NextRequest) {
//   const result = await validateBody(request, UserSchema)
//   if ('error' in result) return result.error
//   const { email, name } = result.data
//   // ...
// }
`,
    language: 'typescript',
    category: 'backend',
    confidence: 95,
    description: 'Zod validation utilities for API routes',
  }
}

/**
 * Generate rate limiter middleware
 */
function generateRateLimiter(): GeneratedFile {
  return {
    path: 'lib/rate-limiter.ts',
    content: `// =============================================================================
// RATE LIMITER MIDDLEWARE
// =============================================================================
// Generated by inprod.ai
// In-memory rate limiting (use Redis for production scale)

import { NextRequest, NextResponse } from 'next/server'

interface RateLimitConfig {
  maxRequests: number
  windowMs: number
}

interface RateLimitEntry {
  count: number
  resetAt: number
}

// In-memory store (replace with Redis for multi-instance deployments)
const store = new Map<string, RateLimitEntry>()

// Cleanup old entries every 5 minutes
if (typeof setInterval !== 'undefined') {
  setInterval(() => {
    const now = Date.now()
    for (const [key, entry] of store.entries()) {
      if (entry.resetAt < now) {
        store.delete(key)
      }
    }
  }, 5 * 60 * 1000)
}

/**
 * Get client IP from request
 */
function getClientIP(request: NextRequest): string {
  const forwarded = request.headers.get('x-forwarded-for')
  const realIp = request.headers.get('x-real-ip')
  return forwarded?.split(',')[0].trim() || realIp || 'unknown'
}

/**
 * Create a rate limiter for API routes
 */
export function createRateLimiter(config: RateLimitConfig) {
  return function rateLimit(
    request: NextRequest
  ): NextResponse | null {
    const ip = getClientIP(request)
    const key = \`rate-limit:\${ip}\`
    const now = Date.now()
    
    const entry = store.get(key)
    
    // Create new entry if none exists or expired
    if (!entry || entry.resetAt < now) {
      store.set(key, { count: 1, resetAt: now + config.windowMs })
      return null
    }
    
    // Check if limit exceeded
    if (entry.count >= config.maxRequests) {
      const retryAfter = Math.ceil((entry.resetAt - now) / 1000)
      
      return NextResponse.json(
        {
          error: 'Too many requests',
          retryAfter,
        },
        {
          status: 429,
          headers: {
            'X-RateLimit-Limit': config.maxRequests.toString(),
            'X-RateLimit-Remaining': '0',
            'X-RateLimit-Reset': entry.resetAt.toString(),
            'Retry-After': retryAfter.toString(),
          },
        }
      )
    }
    
    // Increment counter
    entry.count++
    store.set(key, entry)
    
    return null
  }
}

// Pre-configured limiters
export const apiLimiter = createRateLimiter({
  maxRequests: 100,
  windowMs: 60 * 1000, // 100 req/min
})

export const authLimiter = createRateLimiter({
  maxRequests: 5,
  windowMs: 60 * 1000, // 5 req/min for auth endpoints
})

export const strictLimiter = createRateLimiter({
  maxRequests: 10,
  windowMs: 60 * 1000, // 10 req/min for sensitive endpoints
})

// Usage in API route:
// import { apiLimiter } from '@/lib/rate-limiter'
//
// export async function POST(request: NextRequest) {
//   const limited = apiLimiter(request)
//   if (limited) return limited
//   // ... rest of handler
// }
`,
    language: 'typescript',
    category: 'backend',
    confidence: 90,
    description: 'Rate limiting middleware',
  }
}

/**
 * Generate health check endpoint
 */
function generateHealthEndpoint(ctx: RepoContext): GeneratedFile {
  const isNextJS = ctx.techStack.frameworks.includes('next.js')
  
  if (isNextJS) {
    return {
      path: 'app/api/health/route.ts',
      content: `// =============================================================================
// HEALTH CHECK ENDPOINT
// =============================================================================
// Generated by inprod.ai
// Used by load balancers and monitoring services

import { NextResponse } from 'next/server'

interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy'
  timestamp: string
  version: string
  uptime: number
  checks: {
    name: string
    status: 'pass' | 'fail'
    latencyMs?: number
    message?: string
  }[]
}

const startTime = Date.now()

export async function GET() {
  const checks: HealthStatus['checks'] = []
  
  // Database check (uncomment if using Prisma)
  // try {
  //   const start = performance.now()
  //   await prisma.$queryRaw\`SELECT 1\`
  //   checks.push({
  //     name: 'database',
  //     status: 'pass',
  //     latencyMs: Math.round(performance.now() - start),
  //   })
  // } catch (error) {
  //   checks.push({
  //     name: 'database',
  //     status: 'fail',
  //     message: error instanceof Error ? error.message : 'Unknown error',
  //   })
  // }
  
  // Memory check
  const memUsage = process.memoryUsage()
  const memUsedMB = Math.round(memUsage.heapUsed / 1024 / 1024)
  checks.push({
    name: 'memory',
    status: memUsedMB < 500 ? 'pass' : 'fail',
    message: \`\${memUsedMB}MB heap used\`,
  })
  
  // Determine overall status
  const failedChecks = checks.filter(c => c.status === 'fail')
  let status: HealthStatus['status'] = 'healthy'
  if (failedChecks.length > 0) {
    status = failedChecks.length === checks.length ? 'unhealthy' : 'degraded'
  }
  
  const health: HealthStatus = {
    status,
    timestamp: new Date().toISOString(),
    version: process.env.npm_package_version || '1.0.0',
    uptime: Math.round((Date.now() - startTime) / 1000),
    checks,
  }
  
  return NextResponse.json(health, {
    status: status === 'unhealthy' ? 503 : 200,
    headers: {
      'Cache-Control': 'no-cache, no-store, must-revalidate',
    },
  })
}
`,
      language: 'typescript',
      category: 'backend',
      confidence: 95,
      description: 'Health check API endpoint',
    }
  }
  
  // Express/generic version
  return {
    path: 'routes/health.ts',
    content: `// =============================================================================
// HEALTH CHECK ENDPOINT
// =============================================================================
// Generated by inprod.ai

import { Router, Request, Response } from 'express'

const router = Router()
const startTime = Date.now()

router.get('/health', async (req: Request, res: Response) => {
  const health = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: Math.round((Date.now() - startTime) / 1000),
  }
  
  res.json(health)
})

export default router
`,
    language: 'typescript',
    category: 'backend',
    confidence: 85,
    description: 'Health check endpoint',
  }
}

/**
 * Generate API logger middleware
 */
function generateApiLogger(): GeneratedFile {
  return {
    path: 'lib/api-logger.ts',
    content: `// =============================================================================
// API REQUEST LOGGER
// =============================================================================
// Generated by inprod.ai
// Logs API requests with timing and context

import { NextRequest } from 'next/server'

interface RequestLog {
  timestamp: string
  method: string
  path: string
  status: number
  durationMs: number
  userAgent?: string
  ip?: string
  userId?: string
}

/**
 * Log an API request
 */
function logRequest(log: RequestLog) {
  const message = \`\${log.method} \${log.path} \${log.status} \${log.durationMs}ms\`
  
  if (process.env.NODE_ENV === 'production') {
    // JSON format for log aggregation
    console.log(JSON.stringify(log))
  } else {
    // Human readable for development
    const color = log.status >= 400 ? '\\x1b[31m' : '\\x1b[32m'
    console.log(\`\${color}\${message}\\x1b[0m\`)
  }
}

/**
 * Higher-order function to wrap API handlers with logging
 */
export function withLogging<T>(
  handler: (request: NextRequest, context?: T) => Promise<Response>
) {
  return async (request: NextRequest, context?: T): Promise<Response> => {
    const start = performance.now()
    
    try {
      const response = await handler(request, context)
      
      logRequest({
        timestamp: new Date().toISOString(),
        method: request.method,
        path: request.nextUrl.pathname,
        status: response.status,
        durationMs: Math.round(performance.now() - start),
        userAgent: request.headers.get('user-agent') || undefined,
        ip: request.headers.get('x-forwarded-for')?.split(',')[0].trim(),
      })
      
      return response
    } catch (error) {
      logRequest({
        timestamp: new Date().toISOString(),
        method: request.method,
        path: request.nextUrl.pathname,
        status: 500,
        durationMs: Math.round(performance.now() - start),
      })
      
      throw error
    }
  }
}

// Usage:
// export const POST = withLogging(async (request) => {
//   // ... handler logic
// })
`,
    language: 'typescript',
    category: 'backend',
    confidence: 90,
    description: 'API request logging middleware',
  }
}
