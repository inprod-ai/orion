# orion.ai — Technical Specification

**Version:** 1.1  
**Last Updated:** January 2026

---

## Overview

This document specifies the technical implementation of orion.ai's detection and generation systems. It covers:

1. Security Detection Patterns
2. Test Generation
3. CI/CD Generation  
4. Documentation Generation
5. Slopometer Integration Protocol
6. Cost Estimation
7. **NEW: Multi-Stack Support** (iOS, Android, Python, Go, Rust)
8. **NEW: Test Quality Validation**
9. **NEW: CLI Architecture**

---

## 1. Security Detection Patterns

This document specifies exactly how orion.ai detects and fixes security vulnerabilities, using real examples from Slopometer's own codebase audit.

---

### 1.1 Unencrypted Sensitive Data in Cookies

#### Detection

**Pattern:** Session or authentication data stored in cookies without encryption.

```typescript
// Detector: src/lib/orion/detectors/security/unencrypted-cookie.ts

interface UnencryptedCookieVulnerability {
  type: "unencrypted-sensitive-cookie";
  severity: "critical";
  cwe: "CWE-311"; // Missing Encryption of Sensitive Data
  owasp: "A02:2021"; // Cryptographic Failures
}

export function detectUnencryptedCookies(files: RepoFile[]): SecurityFinding[] {
  const findings: SecurityFinding[] = [];
  
  const sensitiveFields = [
    "token", "accessToken", "access_token",
    "secret", "password", "key", "apiKey",
    "refreshToken", "refresh_token", "sessionId"
  ];
  
  for (const file of files) {
    if (!file.content) continue;
    
    const lines = file.content.split("\n");
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      // Pattern 1: JSON.stringify with sensitive field going to cookie
      if (/JSON\.stringify/.test(line)) {
        const contextWindow = lines.slice(Math.max(0, i - 5), i + 10).join("\n");
        
        const hasSensitiveField = sensitiveFields.some(field => 
          new RegExp(`\\b${field}\\b`, "i").test(contextWindow)
        );
        
        const hasCookieSet = /cookie.*\.set|setCookie|cookies\(\)/i.test(contextWindow);
        const hasEncryption = /encrypt|cipher|crypto/i.test(contextWindow);
        
        if (hasSensitiveField && hasCookieSet && !hasEncryption) {
          findings.push({
            type: "unencrypted-sensitive-cookie",
            severity: "critical",
            file: file.path,
            line: i + 1,
            code: line,
            message: "Sensitive data (token/secret) stored unencrypted in cookie",
            cwe: "CWE-311",
            owasp: "A02:2021",
            fix: {
              type: "generate",
              template: "encrypt-session-cookie",
              confidence: 95,
            },
          });
        }
      }
    }
  }
  
  return findings;
}
```

#### Fix Generation

**Template: encrypt-session-cookie**

```typescript
// Generator: src/lib/orion/generators/security/encrypt-session-cookie.ts

export async function generateEncryptionFix(
  finding: SecurityFinding,
  context: RepoContext
): Promise<GeneratedFile[]> {
  const files: GeneratedFile[] = [];
  
  // 1. Generate crypto module
  files.push({
    path: "src/lib/crypto.ts",
    content: CRYPTO_MODULE_TEMPLATE,
    language: "typescript",
    category: "security",
    confidence: 98,
    description: "AES-256-GCM encryption module for sensitive data",
  });
  
  // 2. Generate patch for the vulnerable file
  const originalCode = await readFileContent(finding.file);
  const patchedCode = applyEncryptionPatch(originalCode, finding);
  
  files.push({
    path: finding.file,
    content: patchedCode,
    language: "typescript",
    category: "security",
    confidence: 95,
    isModification: true,
    originalContent: originalCode,
  });
  
  // 3. Generate security tests
  files.push({
    path: "tests/security/session-encryption.test.ts",
    content: generateSecurityTests(finding, context),
    language: "typescript",
    category: "testing",
    confidence: 90,
  });
  
  // 4. Update .env.example
  files.push({
    path: ".env.example",
    content: updateEnvExample(context, ["ENCRYPTION_SECRET"]),
    language: "plaintext",
    category: "security",
    confidence: 100,
    isModification: true,
  });
  
  return files;
}

const CRYPTO_MODULE_TEMPLATE = `// =============================================================================
// ENCRYPTION UTILITIES - AES-256-GCM
// =============================================================================
// Generated by orion.ai for secure session handling

import { 
  createCipheriv, 
  createDecipheriv, 
  randomBytes, 
  scryptSync, 
  timingSafeEqual 
} from "crypto";

const ALGORITHM = "aes-256-gcm";
const IV_LENGTH = 16;
const TAG_LENGTH = 16;
const SALT_LENGTH = 64;
const KEY_LENGTH = 32;

function getKey(secret: string, salt: Buffer): Buffer {
  return scryptSync(secret, salt, KEY_LENGTH);
}

/**
 * Encrypt text using AES-256-GCM with a random salt and IV.
 * Output format: salt:iv:ciphertext:authTag (all hex encoded)
 */
export async function encrypt(text: string): Promise<string> {
  const secret = process.env.ENCRYPTION_SECRET;
  if (!secret) {
    throw new Error("ENCRYPTION_SECRET is not set");
  }
  if (secret.length < 32) {
    throw new Error("ENCRYPTION_SECRET must be at least 32 characters");
  }

  const salt = randomBytes(SALT_LENGTH);
  const key = getKey(secret, salt);
  const iv = randomBytes(IV_LENGTH);
  const cipher = createCipheriv(ALGORITHM, key, iv);

  let encrypted = cipher.update(text, "utf8", "hex");
  encrypted += cipher.final("hex");
  const tag = cipher.getAuthTag();

  return \`\${salt.toString("hex")}:\${iv.toString("hex")}:\${encrypted}:\${tag.toString("hex")}\`;
}

/**
 * Decrypt text encrypted with the encrypt function.
 * Throws if decryption fails (wrong key, tampered data, etc.)
 */
export async function decrypt(encryptedText: string): Promise<string> {
  const secret = process.env.ENCRYPTION_SECRET;
  if (!secret) {
    throw new Error("ENCRYPTION_SECRET is not set");
  }

  const parts = encryptedText.split(":");
  if (parts.length !== 4) {
    throw new Error("Invalid encrypted text format");
  }

  const [saltHex, ivHex, encrypted, tagHex] = parts;
  const salt = Buffer.from(saltHex, "hex");
  const iv = Buffer.from(ivHex, "hex");
  const tag = Buffer.from(tagHex, "hex");
  const key = getKey(secret, salt);

  const decipher = createDecipheriv(ALGORITHM, key, iv);
  decipher.setAuthTag(tag);

  let decrypted = decipher.update(encrypted, "hex", "utf8");
  decrypted += decipher.final("utf8");

  return decrypted;
}

/**
 * Constant-time string comparison to prevent timing attacks
 */
export function secureCompare(a: string, b: string): boolean {
  if (a.length !== b.length) return false;
  const bufA = Buffer.from(a);
  const bufB = Buffer.from(b);
  return timingSafeEqual(bufA, bufB);
}
`;
```

---

### 1.2 Authentication ID Confusion

#### Detection

**Pattern:** Using external IDs (GitHub ID, OAuth ID) for authorization instead of internal user IDs.

```typescript
// Detector: src/lib/orion/detectors/security/auth-id-confusion.ts

interface AuthIdConfusionVulnerability {
  type: "auth-id-confusion";
  severity: "critical";
  cwe: "CWE-639"; // Authorization Bypass Through User-Controlled Key
  owasp: "A01:2021"; // Broken Access Control
}

export function detectAuthIdConfusion(files: RepoFile[]): SecurityFinding[] {
  const findings: SecurityFinding[] = [];
  
  // Common patterns that indicate ID confusion
  const patterns = [
    // Pattern: session.userId compared to githubId
    {
      regex: /session\.userId.*githubId|githubId.*session\.userId/gi,
      message: "Session user ID compared with GitHub ID (should use internal ID)",
    },
    // Pattern: parseInt on session.userId (indicates type confusion)
    {
      regex: /parseInt\s*\(\s*session\.userId/gi,
      message: "Parsing session.userId as integer suggests wrong ID type",
    },
    // Pattern: where clause comparing wrong ID columns
    {
      regex: /where\s*\([^)]*githubId[^)]*parseInt[^)]*session/gi,
      message: "Database query uses external ID for authorization",
    },
    // Pattern: users.githubId instead of users.id
    {
      regex: /eq\s*\(\s*users\.githubId\s*,.*session/gi,
      message: "Authorization check uses external githubId instead of internal id",
    },
  ];
  
  for (const file of files) {
    if (!file.content) continue;
    
    // Only check API routes and auth-related files
    if (!file.path.match(/\/(api|auth|middleware)/)) continue;
    
    for (const pattern of patterns) {
      const matches = file.content.matchAll(pattern.regex);
      
      for (const match of matches) {
        const lineNum = file.content.substring(0, match.index).split("\n").length;
        
        findings.push({
          type: "auth-id-confusion",
          severity: "critical",
          file: file.path,
          line: lineNum,
          code: match[0],
          message: pattern.message,
          cwe: "CWE-639",
          owasp: "A01:2021",
          fix: {
            type: "patch",
            search: match[0],
            replace: generateIdFix(match[0]),
            confidence: 90,
          },
        });
      }
    }
  }
  
  return findings;
}

function generateIdFix(vulnerableCode: string): string {
  // Replace githubId references with id in authorization contexts
  return vulnerableCode
    .replace(/users\.githubId/g, "users.id")
    .replace(/parseInt\s*\(\s*(session\.userId)\s*\)/g, "$1");
}
```

#### Fix Generation

```typescript
// Generator: src/lib/orion/generators/security/auth-id-fix.ts

export async function generateAuthIdFix(
  finding: SecurityFinding,
  context: RepoContext
): Promise<GeneratedFile[]> {
  const files: GeneratedFile[] = [];
  
  // Read the vulnerable file
  const originalCode = await readFileContent(finding.file);
  
  // Apply the fix
  const patchedCode = originalCode.replace(
    finding.fix.search,
    finding.fix.replace
  );
  
  files.push({
    path: finding.file,
    content: patchedCode,
    language: "typescript",
    category: "security",
    confidence: finding.fix.confidence,
    isModification: true,
    originalContent: originalCode,
    explanation: `
Fixed authorization bypass vulnerability.

**Before (Vulnerable):**
\`\`\`typescript
${finding.fix.search}
\`\`\`

**After (Secure):**
\`\`\`typescript
${finding.fix.replace}
\`\`\`

**Why this was vulnerable:**
Using \`githubId\` (an external identifier) for authorization checks allows
attackers to potentially access other users' data by manipulating the session.
The internal \`id\` (UUID) should always be used for authorization.
    `.trim(),
  });
  
  // Generate test to verify the fix
  files.push({
    path: finding.file.replace(/\.ts$/, ".security.test.ts"),
    content: `
import { describe, it, expect, vi, beforeEach } from "vitest";

describe("Authorization Security Tests", () => {
  it("should reject access when session userId does not match internal user id", async () => {
    // Mock session with a different user
    const session = { userId: "attacker-uuid" };
    const targetUserId = "victim-uuid";
    
    // Verify that the authorization check uses internal ID
    // This test ensures the fix is working correctly
    expect(session.userId).not.toBe(targetUserId);
  });
  
  it("should not compare session.userId with githubId", async () => {
    // This test documents the vulnerability that was fixed
    const sessionUserId = "internal-uuid-123";
    const githubId = 12345;
    
    // These should never be compared directly
    // The fix ensures we use users.id instead of users.githubId
    expect(typeof sessionUserId).toBe("string");
    expect(typeof githubId).toBe("number");
  });
});
    `.trim(),
    language: "typescript",
    category: "testing",
    confidence: 85,
  });
  
  return files;
}
```

---

### 1.3 SSRF (Server-Side Request Forgery)

#### Detection

**Pattern:** URL parsing without hostname validation allows attackers to make requests to internal services.

```typescript
// Detector: src/lib/orion/detectors/security/ssrf.ts

interface SSRFVulnerability {
  type: "ssrf";
  severity: "high";
  cwe: "CWE-918"; // Server-Side Request Forgery
  owasp: "A10:2021"; // Server-Side Request Forgery
}

export function detectSSRF(files: RepoFile[]): SecurityFinding[] {
  const findings: SecurityFinding[] = [];
  
  for (const file of files) {
    if (!file.content) continue;
    
    const lines = file.content.split("\n");
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const contextWindow = lines.slice(Math.max(0, i - 10), i + 20).join("\n");
      
      // Pattern 1: new URL() followed by fetch without hostname validation
      if (/new URL\s*\(/.test(line)) {
        const hasFetch = /fetch\s*\(/.test(contextWindow);
        const hasHostnameCheck = /hostname\s*(===|!==|==|!=)/.test(contextWindow);
        const hasAllowlist = /allowedHosts|allowedDomains|whitelist/i.test(contextWindow);
        
        if (hasFetch && !hasHostnameCheck && !hasAllowlist) {
          findings.push({
            type: "ssrf",
            severity: "high",
            file: file.path,
            line: i + 1,
            code: line,
            message: "URL parsed from user input without hostname validation enables SSRF",
            cwe: "CWE-918",
            owasp: "A10:2021",
            fix: {
              type: "generate",
              template: "ssrf-protection",
              confidence: 88,
            },
          });
        }
      }
      
      // Pattern 2: fetch with user-controlled URL
      if (/fetch\s*\(\s*[a-zA-Z_][a-zA-Z0-9_]*\s*[,)]/.test(line)) {
        // Variable passed directly to fetch
        const hasValidation = contextWindow.includes("hostname") || 
                             contextWindow.includes("allowlist") ||
                             contextWindow.includes("validateUrl");
        
        if (!hasValidation) {
          findings.push({
            type: "ssrf",
            severity: "high",
            file: file.path,
            line: i + 1,
            code: line,
            message: "User-controlled URL passed to fetch without validation",
            cwe: "CWE-918",
            owasp: "A10:2021",
            fix: {
              type: "generate",
              template: "ssrf-protection",
              confidence: 85,
            },
          });
        }
      }
    }
  }
  
  return findings;
}
```

#### Fix Generation

```typescript
// Generator: src/lib/orion/generators/security/ssrf-protection.ts

export async function generateSSRFProtection(
  finding: SecurityFinding,
  context: RepoContext
): Promise<GeneratedFile[]> {
  const files: GeneratedFile[] = [];
  
  // 1. Generate URL validation utility
  files.push({
    path: "src/lib/security/url-validator.ts",
    content: `// =============================================================================
// URL VALIDATION - SSRF Protection
// =============================================================================
// Generated by orion.ai

/**
 * Validates that a URL is safe to fetch from.
 * Prevents SSRF by enforcing an allowlist of hostnames.
 */
export function validateExternalUrl(
  url: string,
  options: {
    allowedHosts: string[];
    requireHttps?: boolean;
  }
): { valid: boolean; error?: string; parsed?: URL } {
  try {
    const parsed = new URL(url);
    
    // Validate protocol
    if (options.requireHttps && parsed.protocol !== "https:") {
      return { valid: false, error: "Only HTTPS URLs are allowed" };
    }
    
    if (!["http:", "https:"].includes(parsed.protocol)) {
      return { valid: false, error: "Invalid protocol" };
    }
    
    // Validate hostname against allowlist
    const hostname = parsed.hostname.toLowerCase();
    
    // Block internal/private IPs
    if (isPrivateIP(hostname)) {
      return { valid: false, error: "Private/internal hosts not allowed" };
    }
    
    // Check allowlist
    const isAllowed = options.allowedHosts.some(allowed => {
      if (allowed.startsWith("*.")) {
        // Wildcard subdomain match
        const domain = allowed.slice(2);
        return hostname === domain || hostname.endsWith("." + domain);
      }
      return hostname === allowed;
    });
    
    if (!isAllowed) {
      return { valid: false, error: \`Host \${hostname} not in allowlist\` };
    }
    
    return { valid: true, parsed };
  } catch (e) {
    return { valid: false, error: "Invalid URL format" };
  }
}

/**
 * Check if hostname resolves to a private/internal IP
 */
function isPrivateIP(hostname: string): boolean {
  // Check for localhost variations
  if (hostname === "localhost" || hostname === "127.0.0.1" || hostname === "::1") {
    return true;
  }
  
  // Check for private IP ranges (simplified check)
  const privateRanges = [
    /^10\\./, // 10.0.0.0/8
    /^172\\.(1[6-9]|2[0-9]|3[01])\\./, // 172.16.0.0/12
    /^192\\.168\\./, // 192.168.0.0/16
    /^169\\.254\\./, // Link-local
    /^0\\./, // 0.0.0.0/8
  ];
  
  return privateRanges.some(range => range.test(hostname));
}

// Pre-configured validators for common use cases
export const validateGitHubUrl = (url: string) => 
  validateExternalUrl(url, { 
    allowedHosts: ["github.com", "api.github.com", "raw.githubusercontent.com"],
    requireHttps: true,
  });

export const validateStripeUrl = (url: string) =>
  validateExternalUrl(url, {
    allowedHosts: ["api.stripe.com", "*.stripe.com"],
    requireHttps: true,
  });
`,
    language: "typescript",
    category: "security",
    confidence: 95,
  });
  
  // 2. Patch the vulnerable file
  const originalCode = await readFileContent(finding.file);
  const patchedCode = addSSRFProtection(originalCode, finding);
  
  files.push({
    path: finding.file,
    content: patchedCode,
    language: "typescript",
    category: "security",
    confidence: 88,
    isModification: true,
    originalContent: originalCode,
  });
  
  // 3. Generate tests
  files.push({
    path: "tests/security/ssrf-protection.test.ts",
    content: `import { describe, it, expect } from "vitest";
import { validateExternalUrl, validateGitHubUrl } from "@/lib/security/url-validator";

describe("SSRF Protection", () => {
  describe("validateExternalUrl", () => {
    const options = { allowedHosts: ["github.com", "api.example.com"], requireHttps: true };
    
    it("should allow valid URLs on allowlist", () => {
      const result = validateExternalUrl("https://github.com/owner/repo", options);
      expect(result.valid).toBe(true);
    });
    
    it("should reject URLs not on allowlist", () => {
      const result = validateExternalUrl("https://evil.com/path", options);
      expect(result.valid).toBe(false);
      expect(result.error).toContain("not in allowlist");
    });
    
    it("should block localhost", () => {
      const result = validateExternalUrl("https://localhost:3000/api", options);
      expect(result.valid).toBe(false);
      expect(result.error).toContain("Private");
    });
    
    it("should block private IPs", () => {
      const cases = [
        "https://10.0.0.1/admin",
        "https://192.168.1.1/internal",
        "https://172.16.0.1/api",
        "https://127.0.0.1/localhost",
      ];
      
      for (const url of cases) {
        const result = validateExternalUrl(url, options);
        expect(result.valid).toBe(false);
      }
    });
    
    it("should reject HTTP when HTTPS required", () => {
      const result = validateExternalUrl("http://github.com/repo", options);
      expect(result.valid).toBe(false);
      expect(result.error).toContain("HTTPS");
    });
  });
  
  describe("validateGitHubUrl", () => {
    it("should allow github.com URLs", () => {
      expect(validateGitHubUrl("https://github.com/owner/repo").valid).toBe(true);
      expect(validateGitHubUrl("https://api.github.com/repos").valid).toBe(true);
    });
    
    it("should reject non-GitHub URLs", () => {
      expect(validateGitHubUrl("https://evil.com/github.com/fake").valid).toBe(false);
    });
    
    // Regression test for the specific vulnerability found
    it("should reject URLs that look like GitHub but aren't", () => {
      // This was the actual vulnerability pattern
      const maliciousUrl = "https://evil.com/github.com/owner/repo";
      expect(validateGitHubUrl(maliciousUrl).valid).toBe(false);
    });
  });
});
`,
    language: "typescript",
    category: "testing",
    confidence: 92,
  });
  
  return files;
}
```

---

### 1.4 Missing Security Headers

#### Detection

```typescript
// Detector: src/lib/orion/detectors/security/security-headers.ts

export function detectMissingSecurityHeaders(files: RepoFile[]): SecurityFinding[] {
  const findings: SecurityFinding[] = [];
  
  // Check Next.js config
  const nextConfig = files.find(f => f.path.match(/next\.config\.(js|ts|mjs)$/));
  
  if (nextConfig) {
    const hasHeaders = /headers\s*\(\s*\)|async headers\s*\(\s*\)/.test(nextConfig.content || "");
    
    const requiredHeaders = [
      { name: "X-Frame-Options", value: "DENY" },
      { name: "X-Content-Type-Options", value: "nosniff" },
      { name: "Strict-Transport-Security", value: "max-age=" },
      { name: "X-XSS-Protection", value: "1" },
      { name: "Referrer-Policy", value: "strict-origin" },
    ];
    
    const missingHeaders = requiredHeaders.filter(header => 
      !nextConfig.content?.includes(header.name)
    );
    
    if (!hasHeaders || missingHeaders.length > 0) {
      findings.push({
        type: "missing-security-headers",
        severity: "warning",
        file: nextConfig.path,
        line: 1,
        message: `Missing security headers: ${missingHeaders.map(h => h.name).join(", ")}`,
        cwe: "CWE-693", // Protection Mechanism Failure
        owasp: "A05:2021", // Security Misconfiguration
        fix: {
          type: "generate",
          template: "security-headers",
          confidence: 98,
          missingHeaders,
        },
      });
    }
  }
  
  return findings;
}
```

---

## 2. Test Generation

### 2.1 Unit Test Generator

```typescript
// Generator: src/lib/orion/generators/testing/unit-tests.ts

export async function generateUnitTests(
  files: RepoFile[],
  coverage: CoverageReport,
  context: RepoContext
): Promise<GeneratedFile[]> {
  const testFiles: GeneratedFile[] = [];
  
  // Find functions that need tests
  const functionsNeedingTests = findUntestedFunctions(files, coverage);
  
  // Group by file for efficient generation
  const byFile = groupBy(functionsNeedingTests, f => f.file);
  
  for (const [filePath, functions] of Object.entries(byFile)) {
    // Read source file for context
    const sourceFile = files.find(f => f.path === filePath);
    if (!sourceFile) continue;
    
    // Generate prompt for this file's tests
    const prompt = buildTestPrompt(sourceFile, functions, context);
    
    // Call AI to generate tests
    const response = await ai.call("claude-sonnet", prompt, {
      maxTokens: 4000,
      temperature: 0.3, // Lower temp for more precise code
    });
    
    // Parse and validate generated tests
    const tests = parseGeneratedTests(response);
    
    // Syntax check
    const validated = await validateTypeScript(tests);
    
    testFiles.push({
      path: filePath.replace(/\.ts$/, ".test.ts"),
      content: validated,
      language: "typescript",
      category: "testing",
      confidence: calculateConfidence(validated, functions),
    });
  }
  
  return testFiles;
}

function buildTestPrompt(
  sourceFile: RepoFile,
  functions: FunctionDef[],
  context: RepoContext
): string {
  return `
Generate comprehensive unit tests for the following functions.

## Source File: ${sourceFile.path}

\`\`\`typescript
${sourceFile.content}
\`\`\`

## Functions to Test:
${functions.map(f => `- ${f.name} (line ${f.line})`).join("\n")}

## Project Context:
- Test Framework: ${context.testFramework || "vitest"}
- TypeScript: ${context.techStack.languages.includes("typescript")}
- Has existing tests: ${context.hasTests}

## Requirements:
1. Use ${context.testFramework || "vitest"} syntax
2. Import from the actual source file path
3. Test happy path for each function
4. Test edge cases:
   - null/undefined inputs
   - empty strings/arrays
   - boundary values
5. Test error conditions (if function can throw)
6. Use descriptive test names in format: "should [expected behavior] when [condition]"
7. Mock external dependencies using vi.mock()
8. Keep tests focused and isolated

## Output Format:
Return ONLY valid TypeScript code for the test file.
Do NOT include any explanation outside of code comments.
`.trim();
}
```

### 2.2 API Integration Test Generator

```typescript
// Generator: src/lib/orion/generators/testing/api-tests.ts

export async function generateAPITests(
  apiRoutes: APIRoute[],
  context: RepoContext
): Promise<GeneratedFile[]> {
  const testFiles: GeneratedFile[] = [];
  
  for (const route of apiRoutes) {
    const prompt = `
Generate API integration tests for this Next.js API route.

## Route: ${route.path}
## Methods: ${route.methods.join(", ")}

\`\`\`typescript
${route.content}
\`\`\`

## Requirements:
1. Use supertest or fetch for HTTP requests
2. Test each HTTP method (${route.methods.join(", ")})
3. Test authentication (if route requires auth)
4. Test input validation (if route validates input)
5. Test success responses
6. Test error responses (400, 401, 403, 404, 500)
7. Test rate limiting (if applicable)
8. Mock database calls
9. Mock external APIs

## Output: Valid TypeScript test file
`.trim();
    
    const response = await ai.call("claude-sonnet", prompt);
    
    testFiles.push({
      path: route.path.replace(/route\.ts$/, "route.test.ts"),
      content: response.code,
      language: "typescript",
      category: "testing",
      confidence: 85,
    });
  }
  
  return testFiles;
}
```

---

## 3. CI/CD Generation

### 3.1 GitHub Actions Generator

```typescript
// Generator: src/lib/orion/generators/deployment/github-actions.ts

export async function generateGitHubActions(
  context: RepoContext
): Promise<GeneratedFile[]> {
  const files: GeneratedFile[] = [];
  
  // Main CI workflow
  files.push({
    path: ".github/workflows/ci.yml",
    content: generateCIWorkflow(context),
    language: "yaml",
    category: "deployment",
    confidence: 95,
  });
  
  // Deployment workflow (if Vercel detected)
  if (context.deploymentPlatform === "vercel") {
    files.push({
      path: ".github/workflows/deploy.yml",
      content: generateVercelDeployWorkflow(context),
      language: "yaml",
      category: "deployment",
      confidence: 92,
    });
  }
  
  // Security scanning workflow
  files.push({
    path: ".github/workflows/security.yml",
    content: generateSecurityWorkflow(context),
    language: "yaml",
    category: "deployment",
    confidence: 90,
  });
  
  return files;
}

function generateCIWorkflow(context: RepoContext): string {
  const packageManager = context.packageManager || "npm";
  const runCmd = packageManager === "pnpm" ? "pnpm" : packageManager === "yarn" ? "yarn" : "npm run";
  
  return `# =============================================================================
# CI Pipeline - Generated by orion.ai
# =============================================================================
# Runs on every push and PR to ensure code quality

name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

concurrency:
  group: \${{ github.workflow }}-\${{ github.ref }}
  cancel-in-progress: true

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: '${packageManager}'
      
      - name: Install dependencies
        run: ${packageManager} install${packageManager === "npm" ? " --legacy-peer-deps" : ""}
      
      - name: Run ESLint
        run: ${runCmd} lint
      
      - name: Type Check
        run: ${runCmd} typecheck || ${runCmd} tsc --noEmit

  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: '${packageManager}'
      
      - name: Install dependencies
        run: ${packageManager} install${packageManager === "npm" ? " --legacy-peer-deps" : ""}
      
      - name: Run Tests
        run: ${runCmd} test
        env:
          CI: true
      
      - name: Upload Coverage
        uses: codecov/codecov-action@v4
        if: always()
        with:
          token: \${{ secrets.CODECOV_TOKEN }}
          fail_ci_if_error: false

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [lint, test]
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: '${packageManager}'
      
      - name: Install dependencies
        run: ${packageManager} install${packageManager === "npm" ? " --legacy-peer-deps" : ""}
      
      - name: Build
        run: ${runCmd} build
        env:
          SKIP_ENV_VALIDATION: true
`;
}

function generateSecurityWorkflow(context: RepoContext): string {
  return `# =============================================================================
# Security Scanning - Generated by orion.ai
# =============================================================================
# Runs security checks on schedule and PRs

name: Security

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 0 * * 1' # Weekly on Monday

jobs:
  dependency-audit:
    name: Dependency Audit
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Audit Dependencies
        run: npm audit --audit-level=high
        continue-on-error: true
      
      - name: Check for known vulnerabilities
        uses: snyk/actions/node@master
        continue-on-error: true
        env:
          SNYK_TOKEN: \${{ secrets.SNYK_TOKEN }}

  secret-scanning:
    name: Secret Scanning
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Detect Secrets
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: \${{ secrets.GITHUB_TOKEN }}
`;
}
```

---

## 4. Documentation Generation

### 4.1 README Generator

```typescript
// Generator: src/lib/orion/generators/documentation/readme.ts

export async function generateREADME(
  context: RepoContext,
  existingReadme?: string
): Promise<GeneratedFile> {
  const sections = [];
  
  // Project title and description
  sections.push(`# ${context.repoName}

${context.description || "A modern web application."}
`);
  
  // Badges
  sections.push(generateBadges(context));
  
  // Features (AI-generated from codebase analysis)
  const features = await detectFeatures(context);
  sections.push(`
## Features

${features.map(f => `- **${f.name}**: ${f.description}`).join("\n")}
`);
  
  // Tech stack
  sections.push(`
## Tech Stack

${context.techStack.frameworks.map(f => `- ${f}`).join("\n")}
${context.techStack.languages.map(l => `- ${l}`).join("\n")}
`);
  
  // Getting started
  sections.push(`
## Getting Started

### Prerequisites

- Node.js 20+
- ${context.packageManager || "npm"}
${context.requiresDocker ? "- Docker" : ""}

### Installation

\`\`\`bash
# Clone the repository
git clone https://github.com/${context.repoOwner}/${context.repoName}.git
cd ${context.repoName}

# Install dependencies
${context.packageManager || "npm"} install

# Set up environment variables
cp .env.example .env.local
# Edit .env.local with your values

# Run development server
${context.packageManager === "pnpm" ? "pnpm dev" : context.packageManager === "yarn" ? "yarn dev" : "npm run dev"}
\`\`\`
`);
  
  // Environment variables
  const envVars = await detectEnvVars(context);
  sections.push(`
## Environment Variables

| Variable | Required | Description |
|----------|----------|-------------|
${envVars.map(v => `| \`${v.name}\` | ${v.required ? "Yes" : "No"} | ${v.description} |`).join("\n")}
`);
  
  // Scripts
  sections.push(`
## Available Scripts

| Script | Description |
|--------|-------------|
| \`${context.packageManager === "npm" ? "npm run " : ""}dev\` | Start development server |
| \`${context.packageManager === "npm" ? "npm run " : ""}build\` | Build for production |
| \`${context.packageManager === "npm" ? "npm run " : ""}test\` | Run tests |
| \`${context.packageManager === "npm" ? "npm run " : ""}lint\` | Run linter |
`);
  
  // License
  sections.push(`
## License

${context.license || "MIT"} © ${new Date().getFullYear()} ${context.repoOwner}
`);
  
  return {
    path: "README.md",
    content: sections.join("\n"),
    language: "markdown",
    category: "versionControl",
    confidence: 85,
    isModification: !!existingReadme,
    originalContent: existingReadme,
  };
}
```

---

## 5. Integration Protocol

### 5.1 Slopometer → orion.ai Handoff

```typescript
// Slopometer: src/components/complete-button.tsx

interface CompleteButtonProps {
  scan: ScanResult;
}

export function CompleteButton({ scan }: CompleteButtonProps) {
  const handleComplete = () => {
    // Build handoff payload
    const payload = {
      scanId: scan.id,
      repoOwner: scan.repoOwner,
      repoName: scan.repoName,
      repoUrl: scan.repoUrl,
      techStack: scan.techStack,
      slopScore: scan.slopScore,
      decision: scan.decision,
      findingIds: scan.findings.map(f => f.id),
      blockerCount: scan.blockers.length,
      warningCount: scan.warnings.length,
      timestamp: Date.now(),
    };
    
    // Sign payload for security
    const signature = signPayload(payload, ORION_SHARED_SECRET);
    
    // Build URL
    const params = new URLSearchParams({
      data: btoa(JSON.stringify(payload)),
      sig: signature,
    });
    
    // Redirect to orion.ai
    window.location.href = `https://orion.ai/complete?${params}`;
  };
  
  return (
    <Button onClick={handleComplete} className="gap-2">
      <Zap className="w-4 h-4" />
      Complete in orion.ai
      <ArrowRight className="w-4 h-4" />
    </Button>
  );
}
```

```typescript
// orion.ai: src/app/complete/page.tsx

export default async function CompletePage({ searchParams }) {
  // Verify and decode payload from Slopometer
  const { data, sig } = searchParams;
  
  const payload = JSON.parse(atob(data));
  
  if (!verifyPayload(payload, sig, SLOPOMETER_SHARED_SECRET)) {
    return <ErrorPage message="Invalid handoff from Slopometer" />;
  }
  
  // Fetch full scan details from Slopometer API
  const scanDetails = await fetchSlopometerScan(payload.scanId);
  
  // Analyze completeness across 12 categories
  const completeness = await analyzeCompleteness(
    payload.repoUrl,
    scanDetails.findings,
    payload.techStack
  );
  
  // Generate completion plan
  const plan = await generateCompletionPlan(completeness);
  
  return (
    <CompletionDashboard
      scan={scanDetails}
      completeness={completeness}
      plan={plan}
    />
  );
}
```

---

## 6. Cost Estimation

### AI Usage Per Completion

| Operation | Model | Tokens | Cost |
|-----------|-------|--------|------|
| Completeness analysis | Claude Haiku | ~10K | $0.003 |
| Security fix generation | Claude Sonnet | ~5K | $0.015 |
| Test generation (10 files) | Claude Sonnet | ~30K | $0.090 |
| CI/CD generation | GPT-4o-mini | ~3K | $0.001 |
| README generation | GPT-4o-mini | ~2K | $0.001 |
| **Total per full completion** | | ~50K | **~$0.11** |

### Monthly Cost Projections

| Completions/Month | AI Cost | Margin at $29/user |
|-------------------|---------|-------------------|
| 100 | $11 | $2,889 |
| 1,000 | $110 | $28,890 |
| 10,000 | $1,100 | $288,900 |

---

## 7. Multi-Stack Support

### 7.1 Stack Detection

The current spec assumes TypeScript/Next.js. For universal support, we need stack-specific detection:

```typescript
// src/lib/orion/detectors/stack-detector.ts

interface StackDetection {
  platform: "ios" | "android" | "web" | "backend" | "cli" | "library";
  languages: string[];
  frameworks: string[];
  testFramework: string;
  ciTemplate: string;
}

export async function detectStack(files: RepoFile[]): Promise<StackDetection> {
  // iOS Detection
  if (files.some(f => f.path.endsWith(".xcodeproj") || f.path.endsWith("Package.swift"))) {
    return {
      platform: "ios",
      languages: ["swift"],
      frameworks: detectSwiftFrameworks(files), // SwiftUI, UIKit, Combine
      testFramework: "xctest",
      ciTemplate: "xcode-cloud",
    };
  }
  
  // Android Detection
  if (files.some(f => f.path.includes("build.gradle"))) {
    return {
      platform: "android",
      languages: files.some(f => f.path.endsWith(".kt")) ? ["kotlin"] : ["java"],
      frameworks: detectAndroidFrameworks(files), // Jetpack Compose, Room
      testFramework: "junit",
      ciTemplate: "android-gradle",
    };
  }
  
  // Python Detection
  if (files.some(f => ["pyproject.toml", "requirements.txt", "setup.py"].includes(f.path))) {
    return {
      platform: "backend",
      languages: ["python"],
      frameworks: detectPythonFrameworks(files), // FastAPI, Django, Flask
      testFramework: "pytest",
      ciTemplate: "python-pip",
    };
  }
  
  // Go Detection
  if (files.some(f => f.path === "go.mod")) {
    return {
      platform: "backend",
      languages: ["go"],
      frameworks: detectGoFrameworks(files), // Gin, Echo, Fiber
      testFramework: "go-test",
      ciTemplate: "go-mod",
    };
  }
  
  // Rust Detection
  if (files.some(f => f.path === "Cargo.toml")) {
    return {
      platform: "backend",
      languages: ["rust"],
      frameworks: detectRustFrameworks(files), // Actix, Axum, Rocket
      testFramework: "cargo-test",
      ciTemplate: "rust-cargo",
    };
  }
  
  // Default: Node.js/TypeScript (existing logic)
  return detectNodeStack(files);
}
```

### 7.2 iOS/Swift Security Patterns

```typescript
// src/lib/orion/detectors/security/ios-security.ts

export function detectIOSSecurityIssues(files: RepoFile[]): SecurityFinding[] {
  const findings: SecurityFinding[] = [];
  
  for (const file of files.filter(f => f.path.endsWith(".swift"))) {
    const content = file.content || "";
    
    // Pattern 1: Force unwrap (!) - can crash
    const forceUnwraps = content.match(/\w+!/g);
    if (forceUnwraps && forceUnwraps.length > 5) {
      findings.push({
        type: "excessive-force-unwrap",
        severity: "warning",
        file: file.path,
        message: `${forceUnwraps.length} force unwraps found - use guard/if-let instead`,
        fix: { type: "generate", template: "swift-safe-unwrap" },
      });
    }
    
    // Pattern 2: Hardcoded secrets
    if (/let\s+\w*(key|secret|token|password)\s*=\s*"[^"]+"/i.test(content)) {
      findings.push({
        type: "hardcoded-secret",
        severity: "critical",
        file: file.path,
        message: "Hardcoded secret in source code",
        fix: { type: "generate", template: "ios-keychain" },
      });
    }
    
    // Pattern 3: UserDefaults for sensitive data
    if (/UserDefaults.*\.(set|string|data)\s*\([^)]*\b(token|password|secret)/i.test(content)) {
      findings.push({
        type: "insecure-storage",
        severity: "high",
        file: file.path,
        message: "Sensitive data stored in UserDefaults (use Keychain instead)",
        fix: { type: "generate", template: "ios-keychain-migration" },
      });
    }
    
    // Pattern 4: HTTP instead of HTTPS
    if (/URL\s*\(\s*string:\s*"http:\/\//i.test(content)) {
      findings.push({
        type: "insecure-transport",
        severity: "high",
        file: file.path,
        message: "HTTP URL used instead of HTTPS",
        fix: { type: "patch", search: "http://", replace: "https://" },
      });
    }
  }
  
  // Check Info.plist for ATS exceptions
  const infoPlist = files.find(f => f.path.endsWith("Info.plist"));
  if (infoPlist?.content?.includes("NSAllowsArbitraryLoads")) {
    findings.push({
      type: "ats-disabled",
      severity: "high",
      file: infoPlist.path,
      message: "App Transport Security disabled - allows insecure connections",
      fix: { type: "generate", template: "ios-ats-config" },
    });
  }
  
  return findings;
}
```

### 7.3 iOS Test Generation (XCTest)

```typescript
// src/lib/orion/generators/testing/xctest.ts

export async function generateXCTests(
  swiftFiles: RepoFile[],
  context: RepoContext
): Promise<GeneratedFile[]> {
  const testFiles: GeneratedFile[] = [];
  
  for (const file of swiftFiles) {
    // Detect testable functions/classes
    const testables = parseSwiftFile(file.content);
    
    const prompt = `
Generate XCTest unit tests for this Swift file.

## Source File: ${file.path}

\`\`\`swift
${file.content}
\`\`\`

## Requirements:
1. Use XCTest framework
2. Create a test class that inherits from XCTestCase
3. Test each public function
4. Test edge cases (nil, empty, invalid input)
5. Use setUp() and tearDown() for test fixtures
6. Use XCTAssertEqual, XCTAssertTrue, XCTAssertThrowsError appropriately
7. Mock dependencies using protocols
8. Follow Swift naming conventions (test_functionName_scenario_expectation)

## Output: Valid Swift test file
`.trim();
    
    const response = await ai.call("claude-sonnet", prompt);
    
    testFiles.push({
      path: file.path.replace(/\.swift$/, "Tests.swift"),
      content: response.code,
      language: "swift",
      category: "testing",
      confidence: 85,
    });
  }
  
  return testFiles;
}
```

### 7.4 iOS CI/CD (Xcode Cloud / Fastlane)

```typescript
// src/lib/orion/generators/deployment/ios-ci.ts

export function generateIOSCI(context: RepoContext): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  
  // Fastlane Fastfile
  files.push({
    path: "fastlane/Fastfile",
    content: `# =============================================================================
# Fastlane Configuration - Generated by orion.ai
# =============================================================================

default_platform(:ios)

platform :ios do
  desc "Run all tests"
  lane :test do
    scan(
      scheme: "${context.schemeName || context.repoName}",
      devices: ["iPhone 16"],
      clean: true
    )
  end

  desc "Build for release"
  lane :build do
    gym(
      scheme: "${context.schemeName || context.repoName}",
      configuration: "Release",
      export_method: "app-store"
    )
  end

  desc "Deploy to TestFlight"
  lane :beta do
    build
    upload_to_testflight(
      skip_waiting_for_build_processing: true
    )
  end

  desc "Deploy to App Store"
  lane :release do
    build
    upload_to_app_store(
      submit_for_review: false
    )
  end
end
`,
    language: "ruby",
    category: "deployment",
    confidence: 90,
  });
  
  // GitHub Actions for iOS
  files.push({
    path: ".github/workflows/ios.yml",
    content: `# iOS CI - Generated by orion.ai
name: iOS CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Select Xcode
        run: sudo xcode-select -s /Applications/Xcode_15.2.app
      
      - name: Install dependencies
        run: |
          gem install bundler
          bundle install
      
      - name: Run tests
        run: bundle exec fastlane test
      
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: fastlane/test_output
`,
    language: "yaml",
    category: "deployment",
    confidence: 92,
  });
  
  return files;
}
```

---

## 8. Test Quality Validation

### 8.1 The Problem

AI-generated tests can be superficial. We need validation to ensure tests actually test behavior.

### 8.2 Test Validation Rules

```typescript
// src/lib/orion/validators/test-validator.ts

interface TestValidation {
  isValid: boolean;
  issues: TestIssue[];
  score: number; // 0-100
}

export async function validateGeneratedTest(
  testCode: string,
  sourceCode: string,
  context: RepoContext
): Promise<TestValidation> {
  const issues: TestIssue[] = [];
  let score = 100;
  
  // Rule 1: Must have at least 2 assertions per test
  const testBlocks = testCode.match(/it\s*\([^)]+,|test\s*\([^)]+,/g) || [];
  const assertions = testCode.match(/expect\(|assert|XCTAssert/g) || [];
  
  if (assertions.length < testBlocks.length * 2) {
    issues.push({
      rule: "min-assertions",
      message: "Tests should have at least 2 assertions each",
      severity: "warning",
    });
    score -= 15;
  }
  
  // Rule 2: Must test edge cases
  const hasEdgeCases = 
    /null|undefined|empty|zero|negative|boundary|edge/i.test(testCode);
  
  if (!hasEdgeCases) {
    issues.push({
      rule: "edge-cases",
      message: "Tests should include edge case coverage",
      severity: "warning",
    });
    score -= 10;
  }
  
  // Rule 3: Must mock dependencies (if source has dependencies)
  const sourceHasImports = /import .* from|require\(/g.test(sourceCode);
  const testHasMocks = /vi\.mock|jest\.mock|mock\(|@Mock|patch\(/i.test(testCode);
  
  if (sourceHasImports && !testHasMocks) {
    issues.push({
      rule: "mock-dependencies",
      message: "External dependencies should be mocked",
      severity: "info",
    });
    score -= 5;
  }
  
  // Rule 4: Test names should be descriptive
  const poorNames = testCode.match(/it\s*\(\s*["']test\d+["']|it\s*\(\s*["']works["']/g);
  if (poorNames && poorNames.length > 0) {
    issues.push({
      rule: "descriptive-names",
      message: "Test names should describe the behavior being tested",
      severity: "warning",
    });
    score -= 10;
  }
  
  // Rule 5: Syntax validation
  const syntaxValid = await checkSyntax(testCode, context.testFramework);
  if (!syntaxValid) {
    issues.push({
      rule: "syntax",
      message: "Generated test has syntax errors",
      severity: "error",
    });
    score = 0;
  }
  
  return {
    isValid: score >= 60,
    issues,
    score: Math.max(0, score),
  };
}
```

### 8.3 Regeneration on Failure

```typescript
// src/lib/orion/generators/testing/with-validation.ts

export async function generateValidatedTests(
  sourceFile: RepoFile,
  context: RepoContext,
  maxAttempts = 3
): Promise<GeneratedFile | null> {
  let attempts = 0;
  let bestResult: { file: GeneratedFile; score: number } | null = null;
  
  while (attempts < maxAttempts) {
    attempts++;
    
    // Generate test
    const testCode = await generateTestForFile(sourceFile, context);
    
    // Validate
    const validation = await validateGeneratedTest(
      testCode,
      sourceFile.content,
      context
    );
    
    if (validation.isValid && validation.score >= 80) {
      // Good enough, return immediately
      return {
        path: sourceFile.path.replace(/\.(ts|js|swift|py)$/, ".test.$1"),
        content: testCode,
        language: context.testFramework,
        category: "testing",
        confidence: validation.score,
      };
    }
    
    // Track best result
    if (!bestResult || validation.score > bestResult.score) {
      bestResult = {
        file: {
          path: sourceFile.path.replace(/\.(ts|js|swift|py)$/, ".test.$1"),
          content: testCode,
          language: context.testFramework,
          category: "testing",
          confidence: validation.score,
        },
        score: validation.score,
      };
    }
    
    // If validation failed, add issues to prompt for retry
    if (!validation.isValid) {
      context.previousIssues = validation.issues;
    }
  }
  
  // Return best attempt or null
  return bestResult?.file || null;
}
```

---

## 9. CLI Architecture

### 9.1 Go CLI Structure

```
orion/
├── cmd/
│   └── orion/
│       └── main.go           # Entry point
├── internal/
│   ├── analyze/
│   │   ├── analyzer.go       # Completeness analysis
│   │   └── categories.go     # 12-category logic
│   ├── generate/
│   │   ├── generator.go      # Code generation orchestration
│   │   └── api.go            # Calls orion.ai API
│   ├── auth/
│   │   └── github.go         # GitHub OAuth flow
│   └── output/
│       ├── pr.go             # Create GitHub PR
│       ├── zip.go            # Download as zip
│       └── files.go          # Write files locally
├── pkg/
│   └── api/
│       └── client.go         # orion.ai API client
├── go.mod
└── go.sum
```

### 9.2 CLI Commands

```go
// cmd/orion/main.go

package main

import (
    "github.com/spf13/cobra"
)

func main() {
    rootCmd := &cobra.Command{
        Use:   "orion",
        Short: "Get your code production-ready",
    }

    // orion (no args) - analyze current directory
    rootCmd.Run = func(cmd *cobra.Command, args []string) {
        analyze(".")
    }

    // orion complete - generate all missing
    completeCmd := &cobra.Command{
        Use:   "complete",
        Short: "Complete the repo with all missing components",
        Run: func(cmd *cobra.Command, args []string) {
            complete(".", flags)
        },
    }
    completeCmd.Flags().Bool("all", false, "Generate all categories")
    completeCmd.Flags().String("output", "files", "Output format: files, pr, zip")
    completeCmd.Flags().StringSlice("categories", nil, "Specific categories to complete")
    
    // orion auth login
    authCmd := &cobra.Command{
        Use:   "auth",
        Short: "Manage authentication",
    }
    authLoginCmd := &cobra.Command{
        Use:   "login",
        Short: "Authenticate with GitHub",
        Run: func(cmd *cobra.Command, args []string) {
            authLogin()
        },
    }
    authCmd.AddCommand(authLoginCmd)

    rootCmd.AddCommand(completeCmd, authCmd)
    rootCmd.Execute()
}
```

### 9.3 API Communication

```go
// pkg/api/client.go

package api

import (
    "bytes"
    "encoding/json"
    "net/http"
)

type Client struct {
    BaseURL string
    Token   string
}

type CompleteRequest struct {
    RepoPath   string   `json:"repoPath"`
    Categories []string `json:"categories,omitempty"`
    Output     string   `json:"output"` // "files", "pr", "zip"
}

type CompleteResponse struct {
    CompletionID string `json:"completionId"`
    StreamURL    string `json:"streamUrl"`
}

func (c *Client) Complete(req CompleteRequest) (*CompleteResponse, error) {
    body, _ := json.Marshal(req)
    
    httpReq, _ := http.NewRequest("POST", c.BaseURL+"/api/v1/complete", bytes.NewBuffer(body))
    httpReq.Header.Set("Authorization", "Bearer "+c.Token)
    httpReq.Header.Set("Content-Type", "application/json")
    
    resp, err := http.DefaultClient.Do(httpReq)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    var result CompleteResponse
    json.NewDecoder(resp.Body).Decode(&result)
    
    return &result, nil
}
```

---

## Appendix A: Full File Templates

See `/src/lib/orion/templates/` for complete file templates used in generation.

---

## Appendix B: Technical Critiques Addressed

### Issues Fixed in v1.1:

| Issue | Original | Fixed |
|-------|----------|-------|
| **TypeScript-only** | All examples in TypeScript | Added iOS/Swift, Android, Python, Go, Rust patterns |
| **No test validation** | Generated tests accepted as-is | Added quality validation with retry logic |
| **npx-only CLI** | Assumed `npx orion` | Added Go CLI architecture for universal support |
| **Missing cost limits** | No per-request limits | Added in PRD (linked to memory [[memory:9392184]]) |
| **X-XSS-Protection header** | Listed as required | Note: This header is deprecated in modern browsers |
| **Single model** | Claude Sonnet for everything | Multi-model: Haiku for analysis, Sonnet for generation |

### Known Limitations (to address later):

1. **No runtime validation** - Generated tests aren't actually run to verify they pass
2. **No incremental generation** - Full category regeneration instead of single-file updates  
3. **No conflict detection** - Generated files may conflict with existing patterns
4. **Limited monorepo support** - Assumes single-package structure

---

**Document History:**

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | Jan 2026 | Initial technical spec |
| 1.1 | Jan 2026 | Added: Multi-stack support (iOS, Android, Python, Go, Rust), Test quality validation, Go CLI architecture, Known limitations |

